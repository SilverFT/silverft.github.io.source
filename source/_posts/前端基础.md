---
title: 前端基础
copyright: false
date: 2019-10-25 23:13:29
tags:
---

## HTML 篇

### 图片中 title 和 alt 区别？

- 通常当鼠标滑动到元素上的时候显示
- `alt`是的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。

### Html5 有哪些新特性、移除了哪些元素

新增元素：

    * 绘画`canvas`
    * 用于媒介回放的`video 和 audio`元素
    * 本地离线存储`localStorage`长期存储数据，浏览器关闭后数据不丢失
    * `sessionStorage`的数据在浏览器关闭后自动删除
    * 语义化更好的内容元素，比如`article 、footer、header、nav、section`
    * 表单控件 ，`calendar 、 date 、 time 、 email 、 url 、 search`
    * 新的技术`webworker 、 websocket 、 Geolocation`

- 移除的元素：

  - 纯表现的元素：`basefont 、 big 、 center 、 font 、 s 、 strike 、 tt 、 u`
  - 对可用性产生负面影响的元素：`frame 、 frameset 、 noframes`

- 支持 HTML5 新标签：

  - `IE8/IE7/IE6`支持通过`document.createElement`方法产生的标签
  - 可以利用这一特性让这些浏览器支持`HTML5`新标签
  - 浏览器支持新标签后，还需要添加标签默认的样式

-

### 浏览器是怎么对 Html5 的离线储存资源进行管理和加载的呢

如何使用：

- 页面头部像下面一样加入一个`manifest`的属性；
- 在`cache.manifest`文件的编写离线存储的资源
- 在离线状态时，操作`window.applicationCache`进行需求实现

在线的情况下，浏览器发现`html`头部有`manifest`属性，它会请求`manifest`文件，如果是第一次访问`app`，那么浏览器就会根据`manifest`文件的内容下载相应的资源并且进行离线存储。如果已经访问过`app`并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的`manifest`文件与旧的`manifest`文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。

### iframe 有那些缺点？

- `iframe`会阻塞主页面的`Onload`事件
- 搜索引擎的检索程序无法解读这种页面，`不利于 SEO`
- `iframe`和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载
- 使用`iframe`之前需要考虑这两个缺点。如果需要使用`iframe`，最好是通过`javascript`动态给`iframe`添加`src`属性值，这样可以绕开以上两个问题

### HTML W3C 的标准

标签闭合、标签小写、不乱嵌套、使用外链 css 和 js 、结构行为表现的分离

### Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?

- `<!DOCTYPE>`声明位于文档中的最前面，处于`html`标签之前。告知浏览器的解析器， 用什么文档类型、规范来解析这个文档
- 严格模式的排版和`JS`运作模式是 以该浏览器支持的最高标准运行
- 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作`DOCTYPE`不存在或格式不正确会导致文档以混杂模式呈现

### HTML 全局属性(global attribute)有哪些

- `class`:为元素设置类标识
- `data-*`: 为元素增加自定义属性
- `draggable`: 设置元素是否可拖拽
- `id`: 元素 id ，文档内唯一
- `lang`: 元素内容的的语言
- `style`: 行内 css 样式
- `title`: 元素相关的建议信息

### viewport 的 content 属性作用

```plain
<meta name="viewport" content="" />
    width viewport的宽度[device-width | pixel_value]width如果直接设置pixel_value数值，大部分的安卓手机不支持，但是ios支持；
    height – viewport 的高度 （范围从 223 到 10,000 ）
    user-scalable [yes | no]是否允许缩放
    initial-scale [数值] 初始化比例（范围从 > 0 到 10）
    minimum-scale [数值] 允许缩放的最小比例
    maximum-scale [数值] 允许缩放的最大比例
    target-densitydpi 值有以下（一般推荐设置中等响度密度或者低像素密度，后者设置具体的值dpi_value，另外webkit内核已不准备再支持此属性）
         -- dpi_value 一般是70-400//没英寸像素点的个数
         -- device-dpi设备默认像素密度
         -- high-dpi 高像素密度
         -- medium-dpi 中等像素密度
         -- low-dpi 低像素密度

复制代码
```

附带问题：怎样处理 移动端 1px 被 渲染成 2px 问题?

局部处理：

- `mate`标签中的`viewport`属性 ，`initial-scale`设置为 1
- `rem`按照设计稿标准走，外加利用`transfrome 的 scale(0.5)`缩小一倍即可；

全局处理：

- `mate`标签中的`viewport`属性 ，`initial-scale`设置为 0.5
- `rem`按照设计稿标准走即可

### meta 相关

```plain
<!DOCTYPE html> <!--H5标准声明，使用 HTML5 doctype，不区分大小写-->
<head lang=”en”> <!--标准的 lang 属性写法-->
<meta charset=’utf-8′> <!--声明文档使用的字符编码-->
<meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/> <!--优先使用指定浏览器使用特定的文档模式-->
<meta name=”description” content=”不超过150个字符”/> <!--页面描述-->
<meta name=”keywords” content=””/> <!-- 页面关键词-->
<meta name=”author” content=”name, email@gmail.com”/> <!--网页作者-->
<meta name=”robots” content=”index,follow”/> <!--搜索引擎抓取-->
<meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-sc
<meta name=”apple-mobile-web-app-title” content=”标题”> <!--iOS 设备 begin-->
<meta name=”apple-mobile-web-app-capable” content=”yes”/> <!--添加到主屏后的标
是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏-->
<meta name=”apple-mobile-web-app-status-bar-style” content=”black”/>
<meta name=”renderer” content=”webkit”> <!-- 启用360浏览器的极速模式(webkit)-->
<meta http-equiv=”X-UA-Compatible” content=”IE=edge”> <!--避免IE使用兼容模式-->
<meta http-equiv=”Cache-Control” content=”no-siteapp” /> <!--不让百度转码-->
<meta name=”HandheldFriendly” content=”true”> <!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器-->
<meta name=”MobileOptimized” content=”320″> <!--微软的老式浏览器-->
<meta name=”screen-orientation” content=”portrait”> <!--uc强制竖屏-->
<meta name=”x5-orientation” content=”portrait”> <!--QQ强制竖屏-->
<meta name=”full-screen” content=”yes”> <!--UC强制全屏-->
<meta name=”x5-fullscreen” content=”true”> <!--QQ强制全屏-->
<meta name=”browsermode” content=”application”> <!--UC应用模式-->
<meta name=”x5-page-mode” content=”app”> <!-- QQ应用模式-->
<meta name=”msapplication-tap-highlight” content=”no”> <!--windows phone
设置页面不缓存-->
<meta http-equiv=”pragma” content=”no-cache”>
<meta http-equiv=”cache-control” content=”no-cache”>
<meta http-equiv=”expires” content=”0″>
复制代码
```

[了解更多参考：https://blog.csdn.net/kongjiea/article/details/17092413](https://blog.csdn.net/kongjiea/article/details/17092413)

### div+css 的布局较 table 布局有什么优点

- 改版的时候更方便 只要改`css`文件。
- 页面加载速度更快、结构化清晰、页面显示简洁。
- 表现与结构相分离。
- 易于优化`（ seo ）`搜索引擎更友好，排名更容易靠前。

### src 与 href 的区别

- `src`用于替换当前元素，`href`用于在当前文档和引用资源之间确立联系。
- `src`是`source`的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求`src`资源时会将其指向的资源下载并应用到文档内，例如`js`脚本，`img`图片和`frame`等元素

> 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部

-`href 是 Hypertext Reference`的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加 -`link href="common.css" rel="stylesheet"`那么浏览器会识别该文档为`css`文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用`link`方式来加载`css`，而不是使用`@import`方式

## CSS 篇

### link 与 @import 的区别

- `link`是`HTML`方式，`@import`是`CSS`方式
- `link`最大限度支持并行下载，`@import`过多嵌套导致串行下载，出现 FOUC (文档样式短暂失效)
- `link`可以通过`rel="alternate stylesheet"`指定候选样式
- 浏览器对`link`支持早于`@import`，可以使用`@import`对老浏览器隐藏样式
- `@import`必须在样式规则之前，可以在`css`文件中引用其他文件
- 总体来说：`link`优于`@import`，`link`优先级也更高

### BFC 有什么用

创建规则：

    * 根元素
    * 浮动元素（`float`不取值为`none`）
    * 绝对定位元素（`position`取值为`absolute`或`fixed`）
    * `display`取值为`inline-block 、 table-cell 、 table-caption 、 flex 、inline-flex`之一的元素
    * `overflow`不取值为`visible`的元素

- 作用

  - 可以包含浮动元素
  - 不被浮动元素覆盖
  - 阻止父子元素的`margin`折叠

-

### 清除浮动的几种方式

- 父级`div`定义`height`
- 结尾处加空`div`标签`clear:both`
- 父级`div`定义伪类`:after`和`zoom`
- 父级`div`定义`overflow:hidden`
- 父级`div`也浮动，需要定义宽度
- 结尾处加`br`标签`clear:both`

### Css3 新增伪类 - 伪元素

- `p:first-of-type`选择属于其父元素的首个 <p> 元素的每个 <p> 元素。
- `p:last-of-type`选择属于其父元素的最后 <p> 元素的每个 <p> 元素。
- `p:only-of-type`选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。
- `p:only-child`选择属于其父元素的唯一子元素的每个 <p> 元素。
- `p:nth-child(2)`选择属于其父元素的第二个子元素的每个 <p> 元素。
- `:enabled`已启用的表单元素。
- `:disabled`已禁用的表单元素。
- `:checked`单选框或复选框被选中。
- `::before`在元素之前添加内容。
- `::after`在元素之后添加内容,也可以用来做清除浮动。
- `::first-line`添加一个特殊的样式到文本的首字母。
- `::first-letter`添加一行特殊样式到首行。

相信大家也看出来他们的不同，

- 伪类语法一个：，它是为了弥补 css 常规类选择器的不足
- 伪元素语法两个：，它是凭空创建的一个虚拟容器生成的元素

### IE 盒子模型 、W3C 盒子模型

W3C 盒模型： 内容(content)、填充( padding )、边界( margin )、 边框( border )；

    * `box-sizing: content-box`
    * width = content width;

- IE 盒子模型： IE 的 content 部分把 border 和 padding 计算了进去;

  - `box-sizing: border-box`
  - width = border + padding + content width

-

### display:inline-block 什么时候不会显示间隙？

- 移除空格
- 使用`margin`负值
- 使用`font-size:0`
- `letter-spacing`
- `word-spacing`

### 行内元素 float:left 后是否变为块级元素？

行内元素设置成浮动之后变得更加像是`inline-block`（行内块级元素，设置 成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是 100% ），这时候给行内元素设置`padding-top`和`padding-bottom`或者`width 、 height`都是有效果的

### 如果需要手动写动画，你认为最小时间间隔是多久，为什么？

多数显示器默认频率是 60Hz ，即 1 秒刷新 60 次，所以理论上最小间隔为 1/60\*1000ms ＝ 16.7ms

### CSS 不同选择器的权重(CSS 层叠的规则)

- `！important`规则最重要，大于其它规则
- 行内样式规则，加 1000
- 对于选择器中给定的各个 ID 属性值，加 100
- 对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加 10
- 对于选择其中给定的各个元素标签选择器，加 1
- 如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则

### stylus/sass/less 区别

- 均具有“变量”、“混合”、“嵌套”、“继承”、“颜色混合”五大基本特性
- `Sass`和`LESS`语法较为严谨，`LESS`要求一定要使用大括号“{}”，`Sass`和`Stylus`可以通过缩进表示层次与嵌套关系
- `Sass`无全局变量的概念，`LESS`和`Stylus`有类似于其它语言的作用域概念
- `Sass`是基于`Ruby`语言的，而`LESS`和`Stylus`可以基于`NodeJS NPM`下载相应库后进行编译；这也是为什么安装 Sass 的时候有时候会报错，需要安装 python 脚本

优点：就不用我多说了，谁用谁知道，真香。

### rgba()和 opacity 的透明效果有什么不同？

- `rgba()`和`opacity`都能实现透明效果，但最大的不同是`opacity`作用于元素，以及元素内的所有内容的透明度，
- 而`rgba()`只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明效果！）

### 水平居中的方法

- 元素为行内元素，设置父元素`text-align:center`
- 如果元素宽度固定，可以设置左右`margin 为 auto`;
- 如果元素为绝对定位，设置父元素`position 为 relative`，元素设`left:0;right:0;margin:auto;`
- 使用`flex-box`布局，指定`justify-content`属性为`center`
- `display`设置为`tabel-ceil`

### 垂直居中的方法

- 将显示方式设置为表格，`display:table-cell`,同时设置`vertial-align：middle`
- 使用`flex`布局，设置为`align-item：center`
- 绝对定位中设置`bottom:0,top:0`,并设置`margin:auto`
- 绝对定位中固定高度时设置`top:50%，margin-top`值为高度一半的负值
- 文本垂直居中设置`line-height`为`height`值

## 浏览器 篇

### 浏览器内核的理解

- 主要分两个部分：`渲染引擎`、`js引擎`
- `渲染引擎：`负责取得网页的内容（html css img ...），以及计算网页的显示方式，然后会输出至显示器或者打印机。浏览器的内核不同对于网页的语法解释也不同，所以渲染的效果也不一样
- `js引擎：`解析和执行 javascript 来实现网页的动态效果
- 最开始渲染引擎和 js 引擎并没有区分的很明确，后来 js 引擎越来越独立，内核就倾向于只值渲染引擎
- `IE : trident`内核
- `Firefox ： gecko`内核
- `Safari : webkit`内核
- `Opera`:以前是`presto`内核，`Opera`现已改用`Google - Chrome`的`Blink`内核
- `Chrome:Blink`(基于`webkit`，`Google与Opera Software`共同开发)

### HTTP 请求+作用？

- `Get`方法：发送一个请求来获取服务器资源
- `POST`方法：向服务器提交数据
- `PUT`方法：与`POST`方法很像，也是提交数据，但`PUT`制定了资源在服务器上的位置，常用在修改数据
- `HEAD`方法：只请求页面的首部信息
- `DELETE`方法：删除服务器上的资源
- `OPTIONS`方法：用于获取当前`URL`支持的请求方式
- `TRACE`方法：用于激活一个远程的应用层请求消息回路
- `CONNECT`方法：把请求链接转换到透明的`TCP/IP`的通道

### HTTP 状态码

`1XX`：信息状态码

    * `100 continue`继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息

- `2XX`：成功状态码

  - `200 ok`正常返回信息
  - `201 created`请求成功并且服务器创建了新资源
  - `202 accepted`服务器已经接收请求，但尚未处理

- `3XX`：重定向

  - `301 move per`请求的网页已经永久重定向
  - `302 found`临时重定向
  - `303 see other`临时冲重定向，且总是使用 get 请求新的 url
  - `304 not modified`自从上次请求后，请求的网页未修改过

- `4XX`：客户端错误

  - `400 bad request`服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求
  - `401 unauthorized`请求未授权
  - `403 forbidden`禁止访问

- - `404 not found`找不到如何与 url 匹配的资源

`5XX`：服务器错误

    * `500 internal server error`最常见的服务器端的错误
    * `503 service unacailable`服务器端暂时无法处理请求（可能是过载活维护）

-

### 从浏览器地址栏输入 URL 后发生了什么？

#### 基础版本

- 1.的浏览器根据请求的`URL`交给`DNS`域名解析，找到真实`IP`，向服务器发起请求；
- 2.服务器交给后台处理完成后返回数据，浏览器接收文件`（ HTML、JS、CSS 、图象等）`；
- 3.浏览器对加载到的资源`（ HTML、JS、CSS 等）`进行语法解析，建立相应的内部数据结构`（如 HTML 的 DOM ）`；
- 4.载入解析到的资源文件，渲染页面，完成。

#### 详细版

- 1.从浏览器接收`url`到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）
- 2.开启网络线程到发出一个完整的`HTTP`请求（这一部分涉及到 dns 查询，`TCP/IP`请求，五层因特网协议栈等知识）
- 3.从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）
- 4.后台和前台的`HTTP`交互（这一部分包括`HTTP`头部、响应码、报文结构、`cookie`等知识，可以提下静态资源的`cookie`优化，以及编码解码，如`gzip`压缩等）
- 5.单独拎出来的缓存问题，`HTTP`的缓存（这部分包括`http缓存头部`，`ETag ， catchcontrol`等）
- 6.浏览器接收到`HTTP`数据包后的解析流程（解析`html`-词法分析然后解析成`dom`树、解析`css`生成`css`规则树、合并成`render`树，然后`layout 、 painting`渲染、复合图层的合成、`GPU`绘制、外链资源的处理、`loaded 和 DOMContentLoaded`等）
- 7.`CSS`的可视化格式模型（元素的渲染规则，如包含块，控制框，`BFC`， IFC 等概念）
- 8.`JS`引擎解析过程（`JS`的解释阶段，预处理阶段，执行阶段生成执行上下文，`VO`，作用域链、回收机制等等）
- 9.其它（可以拓展不同的知识模块，如跨域，`web`安全，`hybrid`模式等等内容）

#### 详细升级版

- 1.在浏览器地址栏输入`URL`

  2.浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤

      * 2.1 如果资源未缓存，发起新请求
      * 2.2 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。

  2.3 检验新鲜通常有两个`HTTP`头进行控制`Expires`和`Cache-Control`：

          * 2.3.1`HTTP1.0`提供`Expires`，值为一个绝对时间表示缓存新鲜日期
          * 2.3.2`HTTP1.1`增加了`Cache-Control: max-age=`,值为以秒为单位的最大新鲜时间
      * *

- 3.浏览器解析`URL`获取协议，主机，端口，`path`
- 4.浏览器组装一个`HTTP（GET）`请求报文

  5.浏览器获取主机`ip地址`，过程如下：

      * 5.1 浏览器缓存
      * 5.2 本机缓存
      * 5.3 hosts文件
      * 5.4 路由器缓存
      * 5.5 ISP DNS缓存
      * 5.6 DNS递归查询（可能存在负载均衡导致每次IP不一致）

- 6.打开一个`socket`与目标`IP地址`，端口建立 TCP 链接，`三次握手`如下：

  - 6.1 客户端发送一个`TCP的SYN=1，Seq=X`的包到服务器端口
  - 6.2 服务器发回`SYN=1，ACK=x+1,Seq=Y`的相应包
  - 6.3 客户端发送`ACK=Y+1，Seq=z`

- - 7.`TCP`链接建立后发送`HTTP`请求
- 8.服务器接收请求后解析，将请求转发到服务器程序，如虚拟主机使用`HTTP Host`头部判断请求的服务程序
- 9.服务器检测`HTTP`请求头是否包含缓存验证信息，如果验证缓存新鲜，返回 304 等对应状态
- 10.出合理程序读取完整请求并准备`HTTP`相应，可能需要查询数据库等操作
- 11.服务器将相应报文通过`TCP`链接发送回浏览器

  12.浏览器接收`HTTP`相应，然后根据情况选择关闭`TCP`链接或者保留重用，关闭 TCP 链接的四次握手如下：

      * 12.1 主动方发送`Fin=1,ACK=z,Seq=x`报文
      * 12.2 被动方发送`ACK=X+1,Seq=Y`报文
      * 12.3 被动方发送`Fin=1,ACK=X,Seq=Y`报文
      * 12.4 主动方发送`ACK=Y,Seq=x`报文

- - 13.浏览器检查相应状态码
- 14.如果资源可缓存，进行缓存
- 15.对相应进行解码
- 16.根据资源类型决定如何处理
- 17.解析`HTML`文档，构建`DOM`树，下载资源，构建`CSSOM`树，执行 js 脚本，这些操作每月严格的先后顺序

  18.构建 DOM 树：

      * 18.1 Tokenizing：根据HTML规范将字符流解析为标记
      * 18.2 Lexing：词法分析将标记转换为对象并定义属性和规则
      * 18.3 DOM construction：根据HTML标记关系将对象组成DOM树

- - 19.解析过程中遇到图片、样式表、js 文件，启动下载

    20.构建`CSSOM`树：

        * 20.1`Tokenizing`：字符流转换为标记流
        * 20.2`Node`：根据标记创建节点
        * 20.3`CSSOM`：节点创建CSSOM树

-     * 根据`DOM树和CSSOM树`构建渲染树
  - 21.1 从`DOM树`的根节点遍历所有可见节点，不可见节点包括：1）`script , meta`这样本身不可见的标签。2)被 css 隐藏的节点，如 display: none
  - 21.2 对每一个可见节点，找到恰当的`CSSOM`规则并应用
  - 21.3 发布可视节点的内容和计算样式
- 22.js 解析如下

  - 22.1 浏览器创建`Document对象`并解析`HTML`，将解析到的元素和文本节点添加到文档中，此时`document.readystate为loading`
  - 22.2 HTML 解析器遇到没有`async和defer的script时`，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用`document.write()`把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容
  - 22.3 当解析器遇到设置了`async属性的script`时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用`document.write()`，它们可以访问自己 script 和之前的文档元素
  - 22.4 当文档完成解析，`document.readState变成interactive`
  - 22.5 所有`defer脚本`会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用`document.write()`
  - 22.6 浏览器在`Document`对象上触发`DOMContentLoaded事件`
  - 22.7 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，`document.readState变为complete，window触发load事件`

- - 23.显示页面（HTML 解析过程中会逐步显示页面）

### cookies ， sessionStorage 和 localStorage 的区别

- `cookie`是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）
- `cookie`数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递（优化点）
- `sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存

存储大小：

    * `cookie`数据大小不能超过4k
    * `sessionStorage 和 localStorage`虽然也有存储大小的限制，但比 cookie 大得多，可以达到5M或更大

- - 有期时间：

`localStorage`存储持久数据，浏览器关闭后数据不丢失除非主动删除数据

`sessionStorage`数据在当前浏览器窗口关闭后自动删除

`cookie 设置的 cookie`过期时间之前一直有效，即使窗口或浏览器关闭

### 浏览器缓存

> 浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下

- 先根据这个资源的一些`http header`判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
- 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些`request header`验证这个资源是否命中协商缓存，称为`http`再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
- 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。
- 当协商缓存也没命中时，服务器就会将资源发送回客户端。
- 当`ctrl+f5`强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
- 当`f5`刷新网页时，跳过强缓存，但是会检查协商缓存；

[强缓存-协商缓存：这篇文章介绍挺细的：https://juejin.cn/post/6844903763665240072#heading-5](https://juejin.cn/post/6844903763665240072#heading-5)

## JS 篇

### 说几条写 JavaScript 的基本规范

- 不要在同一行声明多个变量
- 请是用 ===/!== 来比较`true/false`或者数值
- 使用对象字面量替代`new Array`这种形式
- 不要使用全局函数
- `Switch`语句必须带有`default`分支
- `If`语句必须使用大括号
- `for-in`循环中的变量 应该使用`let`关键字明确限定作用域，从而避免作用域污染

### 绕不过去的闭包

- 闭包就是能够读取其他函数内部变量的函数
- 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个
- 函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域

闭包的特性：

    * 函数内再嵌套函数
    * 内部函数可以引用外层的参数和变量
    * 参数和变量不会被垃圾回收机制回收

- - 优点：能够实现封装和缓存等
- 缺点：消耗内存、使用不当会内存溢出，
- 解决方法：在退出函数之前，将不使用的局部变量全部删除

### 说说你对作用域链的理解

- 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到`window`对象即被终止，作用域链向下访问变量是不被允许的。
- 简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期

### JavaScript 原型，原型链 ? 有什么特点？

- 每个对象都会在其内部初始化一个属性，就是`prototype`(原型)，当我们访问一个对象的属性时,如果这个对象内部不存在这个属性，那么他就会去`prototype`里找这个属性，这个`prototype`又会有自己的`prototype`，于是就这样一直找下去，也就是我们平时所说的原型链的概念
- 关系：`instance.constructor.prototype = instance._proto_`
- 特点：`JavaScript`对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变当我们需要一个属性的时，`Javascript`引擎会先看当前对象中是否有这个属性， 如果没有的,就会查找他的`Prototype`对象是否有这个属性，如此递推下去，一直检索到`Object`内建对象

### 请解释什么是事件委托/事件代理

- 事件代理`（ Event Delegation ）`，又称之为事件委托。是`JavaScript`中常用的绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是`DOM`元素的事件冒泡。使用事件代理的好处是可以提高性能
- 可以大量节省内存占用，减少事件注册，比如在`table`上代理所有`td 的 click`事件就非常棒
- 可以实现当新增子对象时无需再次对其绑定

### Javascript 如何实现继承？

- 构造继承
- 原型继承
- 实例继承
- 拷贝继承
- 原型`prototype`机制或`apply 和 call`方法去实现较简单，建议使用构造函数与原型混合方式

```plain
function Parent(){
this.name = 'wang';
}
function Child(){
 this.age = 28;
}
Child.prototype = new Parent();//继承了Parent，通过原型
var demo = new Child();
alert(demo.age);
alert(demo.name);//得到被继承的属性
复制代码
```

### 谈谈 This 对象的理解

- `this`总是指向函数的直接调用者（而非间接调用者）
- 如果有`new`关键字，`this`指向`new`出来的那个对象
- 在事件中，`this`指向触发这个事件的对象，特殊的是，`IE`中的`attachEvent 中的this`总是指向全局对象`Window`

### 事件模型

> `W3C`中定义事件的发生经历三个阶段：捕获阶段（`capturing`）、目标阶段 （`targetin`）、冒泡阶段（`bubbling`）

- 冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发
- 捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发
- `DOM`事件流：同时支持两种事件模型：捕获型事件和冒泡型事件
- 阻止冒泡：在`W3c`中，使用`stopPropagation()`方法；在 IE 下设置`cancelBubble =true`
- 阻止捕获：阻止事件的默认行为，例如`click - a`后的跳转。在`W3c`中，使用`preventDefault()`方法，在 IE 下设置`window.event.returnValue = false`

### new 操作符具体干了什么呢?

- 创建一个空对象，并且`this`变量引用该对象，同时还继承了该函数的原型
- 属性和方法被加入到`this`引用的对象中
- 新创建的对象由`this`所引用，并且最后隐式的返回`this`

### Ajax 原理

- `Ajax`的原理简单来说是在用户和服务器之间加了—个中间层( AJAX 引擎)，通过`XmlHttpRequest`对象来向服务器发异步请求，从服务器获得数据，然后用`javascript`来操作`DOM`而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据
- `Ajax`的过程只涉及`JavaScript 、 XMLHttpRequest 和 DOM 。 XMLHttpRequest`是`ajax`的核心机制

### 如何解决跨域问题?

> 首先了解下浏览器的同源策略 同源策略`/SOP（Same origin policy）`是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到`XSS 、 CSFR`等攻击。所谓同源是指`"协议+域名+端口"`三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源

- 通过`jsonp`跨域

```plain
var script = document.createElement('script');
script.type = 'text/javascript';
// 传参并指定回调执行函数为onBack
script.src = 'http://www.....:8080/login?user=admin&callback=onBack';
document.head.appendChild(script);
// 回调执行函数
function onBack(res) {
 alert(JSON.stringify(res));
}
复制代码
```

- `document.domain + iframe`跨域

```plain
//父窗口：(http://www.domain.com/a.html)
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
 document.domain = 'domain.com';
 var user = 'admin';
</script>
//子窗口：(http://child.domain.com/b.html)
document.domain = 'domain.com';
// 获取父窗口中变量
alert('get js data from parent ---> ' + window.parent.user);
复制代码
```

- `nginx`代理跨域
- `nodejs`中间件代理跨域
- 后端在头部信息里面设置安全域名

### 说说你对 AMD 和 Commonjs 的理解

- `CommonJS`是服务器端模块的规范，`Node.js`采用了这个规范。`CommonJS`规范加载模

块是同步的，也就是说，只有加载完成，才能执行后面的操作。`AMD`规范则是非同步加载 模块，允许指定回调函数

- `AMD`推荐的风格通过返回一个对象做为模块对象，`CommonJS`的风格通过对

`module.exports 或 exports`的属性赋值来达到暴露模块对象的目的

### js 的 7 种基本数据类型

`Undefined 、 Null 、Boolean 、Number 、String 、Bigint 、Symbol`[感谢：字符搬运工 同学纠正](https://juejin.cn/user/501033034600989)

### 介绍 js 有哪些内置对象

- `Object`是`JavaScript`中所有对象的父对象
- 数据封装类对象：`Object 、 Array 、 Boolean 、 Number 和 String`
- 其他对象：`Function 、 Arguments 、 Math 、 Date 、 RegExp 、 Error`

### JS 有哪些方法定义对象

- 对象字面量：`var obj = {}`;
- 构造函数：`var obj = new Object()`;
- Object.create():`var obj = Object.create(Object.prototype);`

### 你觉得 jQuery 源码有哪些写的好的地方

- `jquery`源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入`window`对象参数，可以使`window`对象作为局部变量使用，好处是当`jquery`中访问`window`对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问`window`对象。同样，传入`undefined`参数，可以缩短查找`undefined`时的作用域链
- `jquery`将一些原型属性和方法封装在了`jquery.prototype`中，为了缩短名称，又赋值给了`jquery.fn`，这是很形象的写法
- 有一些数组或对象的方法经常能使用到，`jQuery`将其保存为局部变量以提高访问速度
- `jquery`实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率

### null，undefined 的区别

- `undefined`表示不存在这个值。
- `undefined`:是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。尝试读取时会返回`undefined`
- 例如变量被声明了，但没有赋值时，就等于`undefined`
- `null`表示一个对象被定义了，值为“空值”
- `null`: 是一个对象(空对象, 没有任何属性和方法)
- 例如作为函数的参数，表示该函数的参数不是对象；
- 在验证`null`时，一定要使用 === ，因为 == 无法分别`null 和 undefined`

### 谈谈你对 ES6 的理解

- 新增模板字符串（为`JavaScript`提供了简单的字符串插值功能）
- 箭头函数
- `for-of`（用来遍历数据—例如数组中的值。）
- `arguments`对象可被不定参数和默认参数完美代替。
- `ES6`将`promise`对象纳入规范，提供了原生的`Promise`对象。
- 增加了`let 和 const`命令，用来声明变量。
- 还有就是引入`module`模块的概念

[更多 ES 新语法：阮一峰的 ES 入门：https://es6.ruanyifeng.com/#docs/style](https://es6.ruanyifeng.com/#docs/style)

### 面向对象编程思想

- 基本思想是使用对象，类，继承，封装等基本概念来进行程序设计
- 易维护
- 易扩展
- 开发工作的重用性、继承性高，降低重复工作量。
- 缩短了开发周期

### 如何通过 JS 判断一个数组

- `instanceof`运算符是用来测试一个对象是否在其原型链原型构造函数的属性

```plain
var arr = [];
arr instanceof Array; // true
复制代码
```

- `isArray`

```plain
Array.isArray([]) //true
Array.isArray(1) //false
复制代码
```

- `constructor`属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数

```plain
var arr = [];
arr.constructor == Array; //true
复制代码
```

- `Object.prototype`

```plain
Object.prototype.toString.call([]) == '[object Array]'
// 写个方法
var isType = function (obj) {
 return Object.prototype.toString.call(obj).slice(8,-1);
 //return Object.prototype.toString.apply([obj]).slice(8,-1);
}
isType([])  //Array
复制代码
```

### 异步编程的实现方式

回调函数

    * 优点：简单、容易理解
    * 缺点：不利于维护，代码耦合高

- 事件监听(采用时间驱动模式，取决于某个事件是否发生)

  - 优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数
  - 缺点：事件驱动型，流程不够清晰

- 发布/订阅(观察者模式)

  - 类似于事件监听，但是可以通过‘消息中心‘，了解现在有多少发布者，多少订阅者

- `Promise`对象

  - 优点：可以利用`then`方法，进行链式写法；可以书写错误时的回调函数；
  - 缺点：编写和理解，相对比较难

- `Generator`函数

  - 优点：函数体内外的数据交换、错误处理机制
  - 缺点：流程管理不方便

- `async`函数

  - 优点：内置执行器、更好的语义、更广的适用性、返回的是`Promise`、结构清晰。
  - 缺点：错误处理机制

-

### 对原生 Javascript 了解方向

数据类型、运算、对象、`Function`、继承、闭包、作用域、原型链、事件、`RegExp`、`JSON`、`Ajax`、`DOM`、`BOM`、内存泄漏、跨域、异步装载、模板引擎、`前端MVC`、路由、模块化、`Canvas`、`ECMAScript`

### sort 快速打乱数组

```plain
var arr = [1,2,3,4,5,6,7,8,9,10];
arr.sort(()=> Math.random() - 0.5)
//利用sort return 大于等于0不交换位置，小于0交换位置
// [5, 8, 4, 3, 2, 9, 10, 6, 1, 7]
复制代码
```

### 数组去重操作

- `ES6 Set`
- `for`循环`indexOf`
- `for`循环`includes`
- `sort`

[详细操作前往：https://juejin.cn/post/6844904035619700750](https://juejin.cn/post/6844904035619700750)

### JS 原生拖拽节点

- 给需要拖拽的节点绑定`mousedown , mousemove , mouseup`事件
- `mousedown`事件触发后，开始拖拽
- `mousemove`时，需要通过`event.clientX 和 clientY`获取拖拽位置，并实时更新位置
- `mouseup`时，拖拽结束
- 需要注意浏览器边界值，设置拖拽范围

### 深拷贝、浅拷贝

- 所有的基础数据类型的赋值操作都是深拷贝
- 通常利用上面这点，来对引用数据类型做递归深拷贝
- 浅拷贝：`Object.assign`或者 扩展运算符

深拷贝：`JSON.parse(JSON.stringify(object))`深层递归

    * 局限性：会忽略 undefined，不能序列化函数，不能解决循环引用的对象

-

[详细信息更多：https://juejin.cn/post/6906369563793817607\*\*](https://juejin.cn/post/6906369563793817607)

### 节流防抖

- 节流：每隔一段时间执行一次，通常用在高频率触发的地方，降低频率。--如：鼠标滑动 拖拽
- 防抖：一段时间内连续触发，不执行，直到超出限定时间执行最后一次。--如：`input`模糊搜索

[更多节流、防抖，细节介绍：https://juejin.cn/post/6844903592898330638](https://juejin.cn/post/6844903592898330638)

### 变量提升

> 当执行`JS`代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境

`js b() // call b console.log(a) // undefined var a = 'Hello world' function b() { console.log('call b') } `

> 变量提升 这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，`JS`解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为`undefined`，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用

```plain
b() // call b second
function b() {
 console.log('call b fist')
}
function b() {
 console.log('call b second')
}
var b = 'Hello world'
复制代码
```

### js 单线程

- 单线程 - 只有一个线程，只能做一件事

原因 - 避免`DOM`渲染的冲突

    * 浏览器需要渲染`DOM`
    * `JS`可以修改`DOM`结构
    * `JS`执行的时候，浏览器`DOM`渲染会暂停
    * 两段`JS`也不能同时执行（都修改`DOM`就冲突了）
    * `webworker`支持多线程，但是不能访问`DOM`

- - 解决方案 - 异步

### 说说 event loop

> 首先，`js`是单线程的，主要的任务是处理用户的交互，而用户的交互无非就 是响应`DOM`的增删改，使用事件队列的形式，一次事件循环只处理一个事件 响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件， 那么事件队列的事件从哪里被`push`进来的呢。那就是另外一个线程叫事件触 发线程做的事情了，他的作用主要是在定时触发器线程、异步`HTTP`请求线程 满足特定条件下的回调函数`push`到事件队列中，等待`js`引擎空闲的时候去 执行，当然`js`引擎执行过程中有优先级之分，首先`js`引擎在一次事件循环中， 会先执行 js 线程的主任务，然后会去查找是否有微任务`microtask（promise）`，如果有那就优先执行微任务，如果没有，在去查找 宏任务`macrotask（setTimeout、setInterval）`进行执行

[更详细的介绍前往：https://juejin.cn/post/6844903598573240327](https://juejin.cn/post/6844903598573240327)

### 描述下 this

> `this`，函数执行的上下文，可以通过`apply ， call ， bind`改变`this`的指向。对于匿名函数或者直接调用的函数来说，this 指向全局上下文（浏览 器为`window，NodeJS为 global`），剩下的函数调用，那就是谁调用它，`this`就指向谁。当然还有`es6`的箭头函数，箭头函数的指向取决于该箭头函 数声明的位置，在哪里声明，`this`就指向哪里

### ajax、axios、fetch 区别

ajax：

- 本身是针对`MVC`的编程,不符合现在前端`MVVM`的浪潮
- 基于原生的`XHR`开发，`XHR`本身的架构不清晰，已经有了`fetch`的替代方案
- `JQuery`整个项目太大，单纯使用`ajax`却要引入整个`JQuery`非常的不合理（采取个性化打包的方案又不能享受`CDN`服务）

axios：

- 从浏览器中创建`XMLHttpRequest`
- 从`node.js`发出`http`请求
- 支持`Promise API`
- 拦截请求和响应
- 转换请求和响应数据
- 取消请求
- 自动转换`JSON`数据
- 客户端支持防止`CSRF/XSRF`

fetch：

- 只对网络请求报错，对 400 ， 500 都当做成功的请求，需要封装去处理
- 默认不会带`cookie`，需要添加配置项（尴尬）
- 本身无自带`abort`，无法超时控制，可以使用 AbortController 解决取消请求问题。
- 没有办法原生监测请求的进度，而`XHR`可以

[更多 fetch 知识前往：阮一峰 fetch](http://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html)

## 优化 篇

### SEO 优化

- 合理的`title 、 description 、 keywords`：搜索对着三项的权重逐个减小，`title`值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面`title`要有所不同；`description`把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面`description`有所不同；`keywords`列举出重要关键词即可
- 语义化的`HTML`代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页
- 重要内容`HTML`代码放在最前：搜索引擎抓取`HTML`顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
- 重要内容不要用`js`输出：爬虫不会执行 js 获取内容
- 少用`iframe`：搜索引擎不会抓取`iframe`中的内容
- 非装饰性图片必须加`alt`
- 提高网站速度：网站速度是搜索引擎排序的一个重要指标

### server 优化

- 减少`HTTP`请求，合并文件、雪碧图
- 减少`DNS`查询，使用缓存
- 减少`Dom`元素的数量
- 使用`CDN`
- 配置`ETag`,http 缓存的手段
- 对组件使用`Gzip`压缩
- 减少`cookie`的大小

### css 优化

- 将样式表放在页面顶部
- 使用`less scss`表达式
- 使用`link`不适用`@import`引入样式
- 压缩`css`
- 禁止使用`gif`图片实现`loading`效果（降低 CPU 消耗，提升渲染性能）
- 使用`CSS3`代码代替`JS`动画（尽可能避免重绘重排以及回流）
- 对于一些小图标，可以使用`base64`位编码，以减少网络请求。
- 页面头部的`<style> <script>`会阻塞页面；（因为 Renderer 进程中 JS 线程和渲染线程是互斥的）
- 当需要设置的样式很多时设置`className`而不是直接操作`style`

### js 方面

- 将脚本放到页面底部
- 将`js`外部引入
- 压缩`js`
- 使用`Eslint`语法检测
- 减少`Dom`的操作
- 熟练使用设计模式
- 禁止使用`iframe`（阻塞父文档`onload`事件）
- 页面中空的`href 和 src`会阻塞页面其他资源的加载
- 网页`gzip ， CDN`托管，`data`缓存 ，图片服务器

### webpack 优化点

- 代码压缩插件`UglifyJsPlugin`
- 服务器启用`gzip`压缩
- 按需加载资源文件`require.ensure`
- 优化`devtool`中的`source-map`
- 剥离`css`文件，单独打包
- 去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致
- 开发环境不做无意义的工作如提取`css`计算文件 hash 等
- 配置`devtool`
- 优化构建时的搜索路径 指明需要构建目录及不需要构建目录

### 其他优化点

为什么利用多个域名来存储网站资源会更有效？

- `CDN`缓存更方便
- 突破浏览器并发限制
- 节约`cookie`带宽
- 节约主域名的连接数，优化页面响应速度
- 防止不必要的安全问题

## Other 篇

### 从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？

- `dns`缓存
- `cdn`缓存
- 浏览器缓存
- 服务器缓存

### 常见 web 安全及防护原理

`sql`注入原理：就是通过把`SQL`命令插入到`Web`表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的`SQL`命令

    * 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双 "-" 进行转换等
    * 永远不要使用动态拼装SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取
    * 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接
    * 不要把机密信息明文存放，请加密或者 hash 掉密码和敏感的信息

- `XSS`防范方法：`Xss(cross-site scripting)`攻击指的是攻击者往`Web`页面里插入恶意`html`标签或者`javascript`代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取`cookie`中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点

  - 首先代码里对用户输入的地方和变量都需要仔细检查长度和对 ”<”,”>”,”;”,”’” 等字符做过滤；其次任何内容写到页面之前都必须加以`encode`，避免不小心把`html tag`弄出来。这一个层面做好，至少可以堵住超过一半的`XSS`攻击

- `XSS与CSRF`有什么区别：`XSS`是获取信息，不需要提前知道其他用户页面的代码和数据包。`CSRF`是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次`CSRF`攻击，受害者必须依次完成两个步骤，1.登录受信任网站 A ，并在本地生成`Cookie`。2.在不登出 A 的情况下，访问危险网站 B

  - 服务端的`CSRF`方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数
  - 通过验证码的方法

-

### 用过哪些设计模式

- 单例模式
- 策略模式
- 代理模式
- 迭代器模式
- 发布—订阅模式

[更多设计模式 15 种：https://www.cnblogs.com/imwtr/p/9451129.html](https://www.cnblogs.com/imwtr/p/9451129.html)

### Node 的应用场景

特点

    * 它是一个`javascript`运行环境
    * 依赖于`chrome V8`引擎进行代码解释
    * 事件驱动
    * 非阻塞 I/o
    * 单进程，单线程

- 优点

  - 对于文件的读写处理效率极高
  - 高并发（`node`最重要的优点）

- 缺点

  - 只支持单核`CPU`，不能充分利用`CPU`
  - 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃

-

### 那些操作会造成内存泄漏？

- 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在
- `setTimeout`的第一个参数使用字符串而非函数的话，会引发内存泄漏
- 闭包使用不当

### 简单介绍下 webpack

`WebPack`是一个模块打包工具，你可以使用`WebPack`管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包`Web`开发中所用到的`HTML 、 Javascript 、 CSS`以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，`webpack`有对应的模块加载器。`webpack`模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。

### 谈谈你对 gulp 的了解

- `gulp`是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成
- `gulp`的核心概念：流
- 流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向
- `gulp`正是通过流和代码优于配置的策略来尽量简化任务编写的工作

`Gulp`的特点：

    * 易于使用：通过代码优于配置的策略，`gulp`让简单的任务简单，复杂的任务可管理
    * 构建快速 利用`Node.js`流的威力，你可以快速构建项目并减少频繁的 IO 操作
    * 易于学习 通过最少的`API`，掌握`gulp`毫不费力，构建工作尽在掌握：如同一系列流管道

-

### 渐进增强和优雅降级

- 渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
- 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容

### 谈一谈你理解的函数式编程

- 简单说，"函数式编程"是一种"编程范式"`（programming paradigm）`，也就是如何编写程序的方法论
- 它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是"第一等公民"、只用"表达式"

[想了解更多，移步这里：https://zhuanlan.zhihu.com/p/57708956](https://zhuanlan.zhihu.com/p/57708956)

### Vue 的双向绑定数据的原理

`vue.js`则是采用数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`来劫持各个属性的`setter ， getter`，在数据变动时发布消息给订阅者，触发相应的监听回调

### 写个简单 Loader

> `loader`就是一个`node`模块，它输出了一个函数。当某种资源需要用这个`loader`转换时，这个函数会被调用。并且，这个函数可以通过提供给它的`this`上下文访问`Loader API 。 reverse-txt-loader`

```plain
// 定义
module.exports = function(src) {
 //src是原文件内容（abcde），下面对内容进行处理，这里是反转
 var result = src.split('').reverse().join('');
 //返回JavaScript源码，必须是String或者Buffer
 return `module.exports = '${result}'`;
}
//使用
{
test: /\.txt$/,
use: [{
'./path/reverse-txt-loader'
}]
},
```

20210203

转载补充

# JS基础

## 1. 如何在ES5环境下实现let

> 这个问题实质上是在回答`let`和`var`有什么区别，对于这个问题，我们可以直接查看`babel`转换前后的结果，看一下在循环中通过`let`定义的变量是如何解决变量提升的问题



![img](https://user-gold-cdn.xitu.io/2020/4/5/1714616e2fd53bf8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

babel在let定义的变量前加了道下划线，避免在块级作用域外访问到该变量，除了对变量名的转换，我们也可以通过自执行函数来模拟块级作用域



```
(function(){
  for(var i = 0; i < 5; i ++){
    console.log(i)  // 0 1 2 3 4
  }
})();

console.log(i)      // Uncaught ReferenceError: i is not defined
复制代码
```

不过这个问题并没有结束，我们回到`var`和`let/const`的区别上：

- `var`声明的变量会挂到window上，而`let`和`const`不会
- `var`声明的变量存在变量提升，而`let`和`const`不会
- `let`和`const`声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问
- 同一作用域下`let`和`const`不能声明同名变量，而`var`可以
- 暂时性死区，`let`和`const`声明的变量不能在声明前被使用

babel的转化，其实只实现了第2、3、5点



## 2. 如何在ES5环境下实现const

实现const的关键在于`Object.defineProperty()`这个API，这个API用于在一个对象上增加或修改属性。通过配置属性描述符，可以精确地控制属性行为。`Object.defineProperty()` 接收三个参数：

> Object.defineProperty(obj, prop, desc)

| 参数       | 说明                       |
| ---------- | -------------------------- |
| obj        | 要在其上定义属性的对象     |
| prop       | 要定义或修改的属性的名称   |
| descriptor | 将被定义或修改的属性描述符 |



| 属性描述符   | 说明                                                         | 默认值    |
| ------------ | ------------------------------------------------------------ | --------- |
| value        | 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined | undefined |
| get          | 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined | undefined |
| set          | 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法 | undefined |
| writable     | 当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false | false     |
| enumerable   | enumerable定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举 | false     |
| Configurable | configurable特性表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改 | false     |

对于const不可修改的特性，我们通过设置writable属性来实现

```
function _const(key, value) {    
    const desc = {        
        value,        
        writable: false    
    }    
    Object.defineProperty(window, key, desc)
}
    
_const('obj', {a: 1})   //定义obj
obj.b = 2               //可以正常给obj的属性赋值
obj = {}                //无法赋值新对象
复制代码
```

参考资料：[如何在 ES5 环境下实现一个const ？](https://juejin.im/post/6844903848008482824)

## 3. 手写call()

> ```
> call() 方法`使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数
>  语法：`function.call(thisArg, arg1, arg2, ...)
> ```

`call()`的原理比较简单，由于函数的this指向它的直接调用者，我们变更调用者即完成this指向的变更：

```
//变更函数调用者示例
function foo() {
    console.log(this.name)
}

// 测试
const obj = {
    name: '写代码像蔡徐抻'
}
obj.foo = foo   // 变更foo的调用者
obj.foo()       // '写代码像蔡徐抻'
复制代码
```

基于以上原理, 我们两句代码就能实现call()

```
Function.prototype.myCall = function(thisArg, ...args) {
    thisArg.fn = this              // this指向调用call的对象,即我们要改变this指向的函数
    return thisArg.fn(...args)     // 执行函数并return其执行结果
}
复制代码
```

但是我们有一些细节需要处理：

```
Function.prototype.myCall = function(thisArg, ...args) {
    const fn = Symbol('fn')        // 声明一个独有的Symbol属性, 防止fn覆盖已有属性
    thisArg = thisArg || window    // 若没有传入this, 默认绑定window对象
    thisArg[fn] = this              // this指向调用call的对象,即我们要改变this指向的函数
    const result = thisArg[fn](...args)  // 执行当前函数
    delete thisArg[fn]              // 删除我们声明的fn属性
    return result                  // 返回函数执行结果
}

//测试
foo.myCall(obj)     // 输出'写代码像蔡徐抻'
复制代码
```



## 4. 手写apply()

> apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。
>  语法：func.apply(thisArg, [argsArray])

`apply()`和`call()`类似，区别在于call()接收参数列表，而apply()接收一个参数数组，所以我们在call()的实现上简单改一下入参形式即可

```
Function.prototype.myApply = function(thisArg, args) {
    const fn = Symbol('fn')        // 声明一个独有的Symbol属性, 防止fn覆盖已有属性
    thisArg = thisArg || window    // 若没有传入this, 默认绑定window对象
    thisArg[fn] = this              // this指向调用call的对象,即我们要改变this指向的函数
    const result = thisArg[fn](...args)  // 执行当前函数（此处说明一下：虽然apply()接收的是一个数组，但在调用原函数时，依然要展开参数数组。可以对照原生apply()，原函数接收到展开的参数数组）
    delete thisArg[fn]              // 删除我们声明的fn属性
    return result                  // 返回函数执行结果
}

//测试
foo.myApply(obj, [])     // 输出'写代码像蔡徐抻'
复制代码
```



## 5. 手写bind()

> `bind()` 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。
>  语法: function.bind(thisArg, arg1, arg2, ...)

从用法上看，似乎给call/apply包一层function就实现了bind()：

```
Function.prototype.myBind = function(thisArg, ...args) {
    return () => {
        this.apply(thisArg, args)
    }
}
复制代码
```

但我们忽略了三点：

1. bind()除了this还接收其他参数，bind()返回的函数也接收参数，这两部分的参数都要传给返回的函数
2. new会改变this指向：如果bind绑定后的函数被new了，那么this指向会发生改变，指向当前函数的实例
3. 没有保留原函数在原型链上的属性和方法

```
Function.prototype.myBind = function (thisArg, ...args) {
    var self = this
    // new优先级
    var fbound = function () {
        self.apply(this instanceof self ? this : thisArg, args.concat(Array.prototype.slice.call(arguments)))
    }
    // 继承原型上的属性和方法
    fbound.prototype = Object.create(self.prototype);

    return fbound;
}

//测试
const obj = { name: '写代码像蔡徐抻' }
function foo() {
    console.log(this.name)
    console.log(arguments)
}

foo.myBind(obj, 'a', 'b', 'c')()    //输出写代码像蔡徐抻 ['a', 'b', 'c']
复制代码
```



## 6. 手写一个防抖函数

防抖和节流的概念都比较简单，所以我们就不在“防抖节流是什么”这个问题上浪费过多篇幅了，简单点一下：

> 防抖，即`短时间内大量触发同一事件，只会执行一次函数`，实现原理为`设置一个定时器，约定在xx毫秒后再触发事件处理，每次触发事件都会重新设置计时器，直到xx毫秒内无第二次操作`，防抖常用于搜索框/滚动条的监听事件处理，如果不做防抖，每输入一个字/滚动屏幕，都会触发事件处理，造成性能浪费。

```
function debounce(func, wait) {
    let timeout = null
    return function() {
        let context = this
        let args = arguments
        if (timeout) clearTimeout(timeout)
        timeout = setTimeout(() => {
            func.apply(context, args)
        }, wait)
    }
}
复制代码
```



## 7. 手写一个节流函数

> 防抖是`延迟执行`，而节流是`间隔执行`，函数节流即`每隔一段时间就执行一次`，实现原理为`设置一个定时器，约定xx毫秒后执行事件，如果时间到了，那么执行函数并重置定时器`，和防抖的区别在于，防抖每次触发事件都重置定时器，而节流在定时器到时间后再清空定时器

```
function throttle(func, wait) {
    let timeout = null
    return function() {
        let context = this
        let args = arguments
        if (!timeout) {
            timeout = setTimeout(() => {
                timeout = null
                func.apply(context, args)
            }, wait)
        }

    }
}
复制代码
```

> 实现方式2：使用两个时间戳`prev旧时间戳`和`now新时间戳`，每次触发事件都判断二者的时间差，如果到达规定时间，执行函数并重置旧时间戳

```
function throttle(func, wait) {
    var prev = 0;
    return function() {
        let now = Date.now();
        let context = this;
        let args = arguments;
        if (now - prev > wait) {
            func.apply(context, args);
            prev = now;
        }
    }
}
复制代码
```



## 8. 数组扁平化

> 对于`[1, [1,2], [1,2,3]]`这样多层嵌套的数组，我们如何将其扁平化为`[1, 1, 2, 1, 2, 3]`这样的一维数组呢：

**1.ES6的flat()**

```
const arr = [1, [1,2], [1,2,3]]
arr.flat(Infinity)  // [1, 1, 2, 1, 2, 3]
复制代码
```

**2.序列化后正则**

```
const arr = [1, [1,2], [1,2,3]]
const str = `[${JSON.stringify(arr).replace(/(\[|\])/g, '')}]`
JSON.parse(str)   // [1, 1, 2, 1, 2, 3]
复制代码
```

**3.递归**
 对于树状结构的数据，最直接的处理方式就是递归

```
const arr = [1, [1,2], [1,2,3]]
function flat(arr) {
  let result = []
  for (const item of arr) {
    item instanceof Array ? result = result.concat(flat(item)) : result.push(item)
  }
  return result
}

flat(arr) // [1, 1, 2, 1, 2, 3]
复制代码
```

**4.reduce()递归**

```
const arr = [1, [1,2], [1,2,3]]
function flat(arr) {
  return arr.reduce((prev, cur) => {
    return prev.concat(cur instanceof Array ? flat(cur) : cur)
  }, [])
}

flat(arr)  // [1, 1, 2, 1, 2, 3]
复制代码
```

**5.迭代+展开运算符**

```
// 每次while都会合并一层的元素，这里第一次合并结果为[1, 1, 2, 1, 2, 3, [4,4,4]]
// 然后arr.some判定数组中是否存在数组，因为存在[4,4,4]，继续进入第二次循环进行合并
let arr = [1, [1,2], [1,2,3,[4,4,4]]]
while (arr.some(Array.isArray)) {
  arr = [].concat(...arr);
}

console.log(arr)  // [1, 1, 2, 1, 2, 3, 4, 4, 4]
复制代码
```



## 9. 手写一个Promise

> 实现一个符合规范的Promise篇幅比较长，建议阅读笔者上一篇文章：[异步编程二三事 | Promise/async/Generator实现原理解析 | 9k字](https://juejin.im/post/6844904096525189128)



# JS面向对象

在JS中一切皆对象，但JS并不是一种真正的面向对象(OOP)的语言，因为它缺少`类(class)`的概念。虽然ES6引入了`class`和`extends`，使我们能够轻易地实现类和继承。但JS并不存在真实的类，JS的类是通过函数以及原型链机制模拟的，本小节的就来探究如何在ES5环境下利用函数和原型链实现JS面向对象的特性

在开始之前，我们先回顾一下原型链的知识，后续`new`和`继承`等实现都是基于原型链机制。很多介绍原型链的资料都能写上洋洋洒洒几千字，但我觉得读者们不需要把原型链想太复杂，容易把自己绕进去，其实在我看来，原型链的核心只需要记住三点：

1. 每个对象都有`__proto__属性`，该属性指向其原型对象，在调用实例的方法和属性时，如果在实例对象上找不到，就会往原型对象上找
2. 构造函数的`prototype属性`也指向实例的原型对象
3. 原型对象的`constructor属性`指向构造函数



![img](https://user-gold-cdn.xitu.io/2020/4/4/17144d68b7d0eea1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



## 1. 模拟实现new

首先我们要知道`new`做了什么

1. **创建一个新对象，并继承其构造函数的`prototype`**，这一步是为了继承构造函数原型上的属性和方法
2. **执行构造函数，方法内的`this`被指定为该新实例**，这一步是为了执行构造函数内的赋值操作
3. **返回新实例**（规范规定，如果构造方法返回了一个对象，那么返回该对象，否则返回第一步创建的新对象）

```
// new是关键字,这里我们用函数来模拟,new Foo(args) <=> myNew(Foo, args)
function myNew(foo, ...args) {
  // 创建新对象,并继承构造方法的prototype属性, 这一步是为了把obj挂原型链上, 相当于obj.__proto__ = Foo.prototype
  let obj = Object.create(foo.prototype)  
  
  // 执行构造方法, 并为其绑定新this, 这一步是为了让构造方法能进行this.name = name之类的操作, args是构造方法的入参, 因为这里用myNew模拟, 所以入参从myNew传入
  let result = foo.apply(obj, args)

  // 如果构造方法已经return了一个对象，那么就返回该对象，否则返回myNew创建的新对象（一般情况下，构造方法不会返回新实例，但使用者可以选择返回新实例来覆盖new创建的对象）
  return Object.prototype.toString.call(result) === '[object Object]' ? result : obj
}

// 测试：
function Foo(name) {
  this.name = name
}
const newObj = myNew(Foo, 'zhangsan')
console.log(newObj)                 // Foo {name: "zhangsan"}
console.log(newObj instanceof Foo)  // true
复制代码
```



## 2. ES5如何实现继承

说到继承，最容易想到的是ES6的`extends`，当然如果只回答这个肯定不合格，我们要从函数和原型链的角度上实现继承，下面我们一步步地、递进地实现一个合格的继承

### 一. 原型链继承

原型链继承的原理很简单，直接让子类的原型对象指向父类实例，当子类实例找不到对应的属性和方法时，就会往它的原型对象，也就是父类实例上找，从而实现对父类的属性和方法的继承

```
// 父类
function Parent() {
    this.name = '写代码像蔡徐抻'
}
// 父类的原型方法
Parent.prototype.getName = function() {
    return this.name
}
// 子类
function Child() {}

// 让子类的原型对象指向父类实例, 这样一来在Child实例中找不到的属性和方法就会到原型对象(父类实例)上寻找
Child.prototype = new Parent()
Child.prototype.constructor = Child // 根据原型链的规则,顺便绑定一下constructor, 这一步不影响继承, 只是在用到constructor时会需要

// 然后Child实例就能访问到父类及其原型上的name属性和getName()方法
const child = new Child()
child.name          // '写代码像蔡徐抻'
child.getName()     // '写代码像蔡徐抻'
复制代码
```

> 原型继承的缺点:

1. 由于所有Child实例原型都指向同一个Parent实例, 因此对某个Child实例的父类引用类型变量修改会影响所有的Child实例
2. 在创建子类实例时无法向父类构造传参, 即没有实现`super()`的功能

```
// 示例:
function Parent() {
    this.name = ['写代码像蔡徐抻'] 
}
Parent.prototype.getName = function() {
    return this.name
}
function Child() {}

Child.prototype = new Parent()
Child.prototype.constructor = Child 

// 测试
const child1 = new Child()
const child2 = new Child()
child1.name[0] = 'foo'
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['foo'] (预期是['写代码像蔡徐抻'], 对child1.name的修改引起了所有child实例的变化)
复制代码
```

### 二. 构造函数继承

构造函数继承，即在子类的构造函数中执行父类的构造函数，并为其绑定子类的`this`，让父类的构造函数把成员属性和方法都挂到`子类的this`上去，这样既能避免实例之间共享一个原型实例，又能向父类构造方法传参

```
function Parent(name) {
    this.name = [name]
}
Parent.prototype.getName = function() {
    return this.name
}
function Child() {
    Parent.call(this, 'zhangsan')   // 执行父类构造方法并绑定子类的this, 使得父类中的属性能够赋到子类的this上
}

//测试
const child1 = new Child()
const child2 = new Child()
child1.name[0] = 'foo'
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['zhangsan']
child2.getName()                  // 报错,找不到getName(), 构造函数继承的方式继承不到父类原型上的属性和方法
复制代码
```

> 构造函数继承的缺点:

1. 继承不到父类原型上的属性和方法

### 三. 组合式继承

既然原型链继承和构造函数继承各有互补的优缺点, 那么我们为什么不组合起来使用呢, 所以就有了综合二者的组合式继承

```
function Parent(name) {
    this.name = [name]
}
Parent.prototype.getName = function() {
    return this.name
}
function Child() {
    // 构造函数继承
    Parent.call(this, 'zhangsan') 
}
//原型链继承
Child.prototype = new Parent()
Child.prototype.constructor = Child

//测试
const child1 = new Child()
const child2 = new Child()
child1.name[0] = 'foo'
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['zhangsan']
child2.getName()                  // ['zhangsan']
复制代码
```

> 组合式继承的缺点:

1. 每次创建子类实例都执行了两次构造函数(`Parent.call()`和`new Parent()`)，虽然这并不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅

### 四. 寄生式组合继承

为了解决构造函数被执行两次的问题, 我们将`指向父类实例`改为`指向父类原型`, 减去一次构造函数的执行

```
function Parent(name) {
    this.name = [name]
}
Parent.prototype.getName = function() {
    return this.name
}
function Child() {
    // 构造函数继承
    Parent.call(this, 'zhangsan') 
}
//原型链继承
// Child.prototype = new Parent()
Child.prototype = Parent.prototype  //将`指向父类实例`改为`指向父类原型`
Child.prototype.constructor = Child

//测试
const child1 = new Child()
const child2 = new Child()
child1.name[0] = 'foo'
console.log(child1.name)          // ['foo']
console.log(child2.name)          // ['zhangsan']
child2.getName()                  // ['zhangsan']
复制代码
```

但这种方式存在一个问题，由于子类原型和父类原型指向同一个对象，我们对子类原型的操作会影响到父类原型，例如给`Child.prototype`增加一个getName()方法，那么会导致`Parent.prototype`也增加或被覆盖一个getName()方法，为了解决这个问题，我们给`Parent.prototype`做一个浅拷贝

```
function Parent(name) {
    this.name = [name]
}
Parent.prototype.getName = function() {
    return this.name
}
function Child() {
    // 构造函数继承
    Parent.call(this, 'zhangsan') 
}
//原型链继承
// Child.prototype = new Parent()
Child.prototype = Object.create(Parent.prototype)  //将`指向父类实例`改为`指向父类原型`
Child.prototype.constructor = Child

//测试
const child = new Child()
const parent = new Parent()
child.getName()                  // ['zhangsan']
parent.getName()                 // 报错, 找不到getName()
复制代码
```

到这里我们就完成了ES5环境下的继承的实现，这种继承方式称为`寄生组合式继承`，是目前最成熟的继承方式，babel对ES6继承的转化也是使用了寄生组合式继承

我们回顾一下实现过程：
 一开始最容易想到的是`原型链继承`，通过把子类实例的原型指向父类实例来继承父类的属性和方法，但原型链继承的缺陷在于`对子类实例继承的引用类型的修改会影响到所有的实例对象`以及`无法向父类的构造方法传参`。
 因此我们引入了`构造函数继承`, 通过在子类构造函数中调用父类构造函数并传入子类this来获取父类的属性和方法，但构造函数继承也存在缺陷，构造函数继承`不能继承到父类原型链上的属性和方法`。
 所以我们综合了两种继承的优点，提出了`组合式继承`，但组合式继承也引入了新的问题，它`每次创建子类实例都执行了两次父类构造方法`，我们通过将`子类原型指向父类实例`改为`子类原型指向父类原型的浅拷贝`来解决这一问题，也就是最终实现 —— `寄生组合式继承`



![img](https://user-gold-cdn.xitu.io/2020/4/6/1714fd86c8983189?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)





# V8引擎机制

## 1. V8如何执行一段JS代码



![img](https://user-gold-cdn.xitu.io/2020/2/5/1701324268cca319?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



1. **预解析**：检查语法错误但不生成AST
2. **生成AST**：经过词法/语法分析，生成抽象语法树
3. **生成字节码**：基线编译器(Ignition)将AST转换成字节码
4. **生成机器码**：优化编译器(Turbofan)将字节码转换成优化过的机器码，此外在逐行执行字节码的过程中，如果一段代码经常被执行，那么V8会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码，优化了执行速度

上面几点只是V8执行机制的极简总结，建议阅读参考资料：

> 1.[V8 是怎么跑起来的 —— V8 的 JavaScript 执行管道](https://juejin.im/post/6844903990073753613)
>  2.[JavaScript 引擎 V8 执行流程概述](https://juejin.im/post/6844904021451505677)

## 2. 介绍一下引用计数和标记清除

- **引用计数**：给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量变成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为0的对象。但是当对象循环引用时，会导致引用次数永远无法归零，造成内存无法释放。
- **标记清除**：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象。

## 3. V8如何进行垃圾回收

JS引擎中对变量的存储主要有两种位置，栈内存和堆内存，栈内存存储基本类型数据以及引用类型数据的内存地址，堆内存储存引用类型的数据



![img](https://user-gold-cdn.xitu.io/2020/4/5/17149730709e41a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



> 栈内存的回收：

栈内存调用栈上下文切换后就被回收，比较简单

> 堆内存的回收：

V8的堆内存分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代内存存在时间长



![img](https://user-gold-cdn.xitu.io/2020/4/5/1714980cac75fc32?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



- 新生代内存回收机制：
  - 新生代内存容量小，64位系统下仅有32M。新生代内存分为**From、To**两部分，进行垃圾回收时，先扫描From，将非存活对象回收，将存活对象顺序复制到To中，之后调换From/To，等待下一次回收
- 老生代内存回收机制
  - **晋升**：如果新生代的变量经过多次回收依然存在，那么就会被放入老生代内存中
  - **标记清除**：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收被标记的对象
  - **整理内存碎片**：把对象挪到内存的一端

> 参考资料：[聊聊V8引擎的垃圾回收](https://juejin.im/post/6844903591510016007#heading-10)

## 4. JS相较于C++等语言为什么慢，V8做了哪些优化

1. JS的问题：
   - **动态类型**：导致每次存取属性/寻求方法时候，都需要先检查类型；此外动态类型也很难在编译阶段进行优化
   - **属性存取**：C++/Java等语言中方法、属性是存储在数组中的，仅需数组位移就可以获取，而JS存储在对象中，每次获取都要进行哈希查询
2. V8的优化：
   - **优化JIT(即时编译)**：相较于C++/Java这类编译型语言，JS一边解释一边执行，效率低。V8对这个过程进行了优化：如果一段代码被执行多次，那么V8会把这段代码转化为机器码缓存下来，下次运行时直接使用机器码。
   - **隐藏类**：对于C++这类语言来说，仅需几个指令就能通过偏移量获取变量信息，而JS需要进行字符串匹配，效率低，V8借用了类和偏移位置的思想，将对象划分成不同的组，即隐藏类
   - **内嵌缓存**：即缓存对象查询的结果。常规查询过程是：获取隐藏类地址 -> 根据属性名查找偏移值 -> 计算该属性地址，内嵌缓存就是对这一过程结果的缓存
   - **垃圾回收管理**：上文已介绍



![img](https://user-gold-cdn.xitu.io/2020/4/5/1714a1f7c054c657?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



> 参考资料：[为什么V8引擎这么快？](https://zhuanlan.zhihu.com/p/27628685)



# 浏览器渲染机制

## 1. 浏览器的渲染过程是怎样的



![img](https://user-gold-cdn.xitu.io/2020/2/5/17013323c225bd62?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

大体流程如下：



1. HTML和CSS经过各自解析，生成DOM树和CSSOM树
2. 合并成为渲染树
3. 根据渲染树进行布局
4. 最后调用GPU进行绘制，显示在屏幕上

## 2. 如何根据浏览器渲染机制加快首屏速度

1. **优化文件大小**：HTML和CSS的加载和解析都会阻塞渲染树的生成，从而影响首屏展示速度，因此我们可以通过优化文件大小、减少CSS文件层级的方法来加快首屏速度
2. **避免资源下载阻塞文档解析**：浏览器解析到<script>标签时，会阻塞文档解析，直到脚本执行完成，因此我们通常把<script>标签放在底部，或者加上`defer、async`来进行异步下载

## 3. 什么是回流(重排)，什么情况下会触发回流

- 当元素的尺寸或者位置发生了变化，就需要重新计算渲染树，这就是回流
- DOM元素的几何属性(`width/height/padding/margin/border`)发生变化时会触发回流
- DOM元素移动或增加会触发回流
- 读写`offset/scroll/client`等属性时会触发回流
- 调用`window.getComputedStyle`会触发回流

## 4. 什么是重绘，什么情况下会触发重绘

- DOM样式发生了变化，但没有影响DOM的几何属性时，会触发重绘，而不会触发回流。重绘由于DOM位置信息不需要更新，省去了布局过程，因而性能上优于回流

## 5. 什么是GPU加速，如何使用GPU加速，GPU加速的缺点

- **优点**：使用transform、opacity、filters等属性时，会直接在GPU中完成处理，这些属性的变化不会引起回流重绘
- **缺点**：GPU渲染字体会导致字体模糊，过多的GPU处理会导致内存问题

## 6. 如何减少回流

- 使用`class`替代`style`，减少style的使用
- 使用`resize、scroll`时进行防抖和节流处理，这两者会直接导致回流
- 使用`visibility`替换`display: none`，因为前者只会引起重绘，后者会引发回流
- 批量修改元素时，可以先让元素脱离文档流，等修改完毕后，再放入文档流
- 避免触发同步布局事件，我们在获取`offsetWidth`这类属性的值时，可以使用变量将查询结果存起来，避免多次查询，每次对`offset/scroll/client`等属性进行查询时都会触发回流
- 对于复杂动画效果,使用绝对定位让其脱离文档流，复杂的动画效果会频繁地触发回流重绘，我们可以将动画元素设置绝对定位从而脱离文档流避免反复回流重绘。



![img](https://user-gold-cdn.xitu.io/2020/4/5/1714a1d84ab05ba9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



> 参考资料：[必须明白的浏览器渲染机制](https://juejin.im/post/6844903846834094094)



# 浏览器缓存策略

## 1. 介绍一下浏览器缓存位置和优先级

1. Service Worker
2. Memory Cache（内存缓存）
3. Disk Cache（硬盘缓存）
4. Push Cache（推送缓存）
5. 以上缓存都没命中就会进行网络请求

## 2. 说说不同缓存间的差别

> 1. Service Worker

和Web Worker类似，是独立的线程，我们可以在这个线程中缓存文件，在主线程需要的时候读取这里的文件，Service Worker使我们可以自由选择缓存哪些文件以及文件的匹配、读取规则，并且缓存是持续性的

> 1. Memory Cache

即内存缓存，内存缓存不是持续性的，缓存会随着进程释放而释放

> 1. Disk Cache

即硬盘缓存，相较于内存缓存，硬盘缓存的持续性和容量更优，它会根据HTTP header的字段判断哪些资源需要缓存

> 1. Push Cache

即推送缓存，是HTTP/2的内容，目前应用较少

## 3. 介绍一下浏览器缓存策略

> 强缓存(不要向服务器询问的缓存)

**设置Expires**

- 即过期时间，例如`「Expires: Thu, 26 Dec 2019 10:30:42 GMT」`表示缓存会在这个时间后失效，这个过期日期是绝对日期，如果修改了本地日期，或者本地日期与服务器日期不一致，那么将导致缓存过期时间错误。

**设置Cache-Control**

- HTTP/1.1新增字段，Cache-Control可以通过`max-age`字段来设置过期时间，例如`「Cache-Control:max-age=3600」`除此之外Cache-Control还能设置`private/no-cache`等多种字段

> 协商缓存(需要向服务器询问缓存是否已经过期)

**Last-Modified**

- 即最后修改时间，浏览器第一次请求资源时，服务器会在响应头上加上`Last-Modified` ，当浏览器再次请求该资源时，浏览器会在请求头中带上`If-Modified-Since` 字段，字段的值就是之前服务器返回的最后修改时间，服务器对比这两个时间，若相同则返回304，否则返回新资源，并更新Last-Modified

**ETag**

- HTTP/1.1新增字段，表示文件唯一标识，只要文件内容改动，ETag就会重新计算。缓存流程和 Last-Modified 一样：服务器发送 ETag 字段 -> 浏览器再次请求时发送 If-None-Match -> 如果ETag值不匹配，说明文件已经改变，返回新资源并更新ETag，若匹配则返回304

> 两者对比

- ETag 比 Last-Modified 更准确：如果我们打开文件但并没有修改，Last-Modified 也会改变，并且 Last-Modified 的单位时间为一秒，如果一秒内修改完了文件，那么还是会命中缓存
- 如果什么缓存策略都没有设置，那么浏览器会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间



![img](https://user-gold-cdn.xitu.io/2020/4/5/1714a298b93c3208?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



> 参考资料：[浏览器缓存机制剖析](https://juejin.im/post/6844903473268391943)



# 网络相关

## 1. 讲讲网络OSI七层模型，TCP/IP和HTTP分别位于哪一层



![alt](https://user-gold-cdn.xitu.io/2020/1/28/16fec363208256b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



| 模型       | 概述                                                   | 单位   |
| ---------- | ------------------------------------------------------ | ------ |
| 物理层     | 网络连接介质，如网线、光缆，数据在其中以比特为单位传输 | bit    |
| 数据链路层 | 数据链路层将比特封装成数据帧并传递                     | 帧     |
| 网络层     | 定义IP地址，定义路由功能，建立主机到主机的通信         | 数据包 |
| 传输层     | 负责将数据进行可靠或者不可靠传递，建立端口到端口的通信 | 数据段 |
| 会话层     | 控制应用程序之间会话能力，区分不同的进程               |        |
| 表示层     | 数据格式标识，基本压缩加密功能                         |        |
| 应用层     | 各种应用软件                                           |        |



## 2. 常见HTTP状态码有哪些

> 2xx 开头（请求成功）

`200 OK`：客户端发送给服务器的请求被正常处理并返回



> 3xx 开头（重定向）

`301 Moved Permanently`：永久重定向，请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置

`302 Moved Permanently`：临时重定向，请求的网页已临时移动到新位置。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

`304 Not Modified`：未修改，自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容



> 4xx 开头（客户端错误）

`400 Bad Request`：错误请求，服务器不理解请求的语法，常见于客户端传参错误

`401 Unauthorized`：未授权，表示发送的请求需要有通过 HTTP 认证的认证信息，常见于客户端未登录

`403 Forbidden`：禁止，服务器拒绝请求，常见于客户端权限不足

`404 Not Found`：未找到，服务器找不到对应资源



> 5xx 开头（服务端错误）

`500 Inter Server Error`：服务器内部错误，服务器遇到错误，无法完成请求

`501 Not Implemented`：尚未实施，服务器不具备完成请求的功能

`502 Bad Gateway`：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。

`503 service unavailable`：服务不可用，服务器目前无法使用（处于超载或停机维护状态）。通常是暂时状态。



## 3. GET请求和POST请求有何区别

> 标准答案：

- GET请求参数放在URL上，POST请求参数放在请求体里
- GET请求参数长度有限制，POST请求参数长度可以非常大
- POST请求相较于GET请求安全一点点，因为GET请求的参数在URL上，且有历史记录
- GET请求能缓存，POST不能

> 更进一步：

其实HTTP协议并没有要求GET/POST请求参数必须放在URL上或请求体里，也没有规定GET请求的长度，目前对URL的长度限制，是各家浏览器设置的限制。GET和POST的根本区别在于：**GET请求是幂等性的，而POST请求不是**

> 幂等性，指的是对某一资源进行一次或多次请求都具有相同的副作用。例如搜索就是一个幂等的操作，而删除、新增则不是一个幂等操作。

由于GET请求是幂等的，在网络不好的环境中，GET请求可能会重复尝试，造成重复操作数据的风险，因此，GET请求用于无副作用的操作(如搜索)，新增/删除等操作适合用POST

> 参考资料：[HTTP｜GET 和 POST 区别？网上多数答案都是错的](https://juejin.im/entry/6844903489127219214)



## 4. HTTP的请求报文由哪几部分组成

> 一个HTTP请求报文由请求行（request line）、请求头（header）、空行和请求数据4个部分组成



![img](https://user-gold-cdn.xitu.io/2020/2/1/16ffe7606c8db5e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

响应报文和请求报文结构类似，不再赘述



## 5. HTTP常见请求/响应头及其含义

> 通用头（请求头和响应头都有的首部）

| 字段              | 作用                                   | 值                                                           |
| ----------------- | -------------------------------------- | ------------------------------------------------------------ |
| Cache-Control     | 控制缓存                               | public：表示响应可以被任何对象缓存(包括客户端/代理服务器) private(默认值)：响应只能被单个客户缓存,不能被代理服务器缓存 no-cache：缓存要经过服务器验证，在浏览器使用缓存前，会对比ETag，若没变则返回304，使用缓存 no-store：禁止任何缓存 |
| Connection        | 是否需要持久连接(HTTP 1.1默认持久连接) | keep-alive / close                                           |
| Transfer-Encoding | 报文主体的传输编码格式                 | chunked(分块) / identity(未压缩和修改) / gzip(LZ77压缩) / compress(LZW压缩,弃用) / deflate(zlib结构压缩) |

> 请求头

| 字段                | 作用                                                         | 语法                                                         |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Accept              | 告知（服务器）客户端可以处理的内容类型                       | text/html、image/*、*/*                                      |
| If-Modified-Since   | 将`Last-Modified`的值发送给服务器，询问资源是否已经过期(被修改)，过期则返回新资源，否则返回304 | 示例：If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT       |
| If-Unmodified-Since | 将`Last-Modified`的值发送给服务器，询问文件是否被修改，若没有则返回200，否则返回412预处理错误，可用于断点续传。通俗点说`If-Unmodified-Since`是文件没有修改时下载，`If-Modified-Since`是文件修改时下载 | 示例：If-Unmodified-Since: Wed, 21 Oct 2015 07:28:00 GMT     |
| If-None-Match       | 将`ETag`的值发送给服务器，询问资源是否已经过期(被修改)，过期则返回新资源，否则返回304 | 示例：If-None-Match: "bfc13a6472992d82d"                     |
| If-Match            | 将`ETag`的值发送给服务器，询问文件是否被修改，若没有则返回200，否则返回412预处理错误，可用于断点续传 | 示例：If-Match: "bfc129c88ca92d82d"                          |
| Range               | 告知服务器返回文件的哪一部分, 用于断点续传                   | 示例：Range: bytes=200-1000, 2000-6576, 19000-               |
| Host                | 指明了服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的TCP端口号 | 示例：Host:www.baidu.com                                     |
| User-Agent          | 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本    | User-Agent: Mozilla/<version> (<system-information>) <platform> (<platform-details>) <extensions> |

> 响应头

| 字段     | 作用                                                         | 语法                 |
| -------- | ------------------------------------------------------------ | -------------------- |
| Location | 需要将页面重新定向至的地址。一般在响应码为3xx的响应中才会有意义 | Location: <url>      |
| ETag     | 资源的特定版本的标识符，如果内容没有改变，Web服务器不需要发送完整的响应 | ETag: "<etag_value>" |
| Server   | 处理请求的源头服务器所用到的软件相关信息                     | Server: <product>    |

> 实体头（针对请求报文和响应报文的实体部分使用首部）

| 字段          | 作用                                                         | 语法                                                         |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Allow         | 资源可支持http请求的方法                                     | Allow: <http-methods>，示例：Allow: GET, POST, HEAD          |
| Last-Modified | 资源最后的修改时间，用作一个验证器来判断接收到的或者存储的资源是否彼此一致，精度不如ETag | 示例：Last-Modified: Wed, 21 Oct 2020 07:28:00 GMT           |
| Expires       | 响应过期时间                                                 | Expires: <http-date>，示例：Expires: Wed, 21 Oct 2020 07:28:00 GMT |

HTTP首部当然不止这么几个，但为了避免写太多大家记不住(主要是别的我也没去看)，这里只介绍了一些常用的，详细的可以看[MDN的文档](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)



## 6. HTTP/1.0和HTTP/1.1有什么区别

- **长连接：** HTTP/1.1支持长连接和请求的流水线，在一个TCP连接上可以传送多个HTTP请求，避免了因为多次建立TCP连接的时间消耗和延时
- **缓存处理：** HTTP/1.1引入`Entity tag，If-Unmodified-Since, If-Match, If-None-Match`等新的请求头来控制缓存，详见浏览器缓存小节
- **带宽优化及网络连接的使用：** HTTP1.1则在请求头引入了range头域，支持断点续传功能
- **Host头处理：** 在HTTP/1.0中认为每台服务器都有唯一的IP地址，但随着虚拟主机技术的发展，多个主机共享一个IP地址愈发普遍，HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会400错误



## 7. 介绍一下HTTP/2.0新特性

- **多路复用：** 即多个请求都通过一个TCP连接并发地完成
- **服务端推送：** 服务端能够主动把资源推送给客户端
- **新的二进制格式：** HTTP/2采用二进制格式传输数据，相比于HTTP/1.1的文本格式，二进制格式具有更好的解析性和拓展性
- **header压缩：** HTTP/2压缩消息头，减少了传输数据的大小



## 8. 说说HTTP/2.0多路复用基本原理以及解决的问题

> HTTP/2解决的问题，就是HTTP/1.1存在的问题：

- **TCP慢启动：** TCP连接建立后，会经历一个先慢后快的发送过程，就像汽车启动一般，如果我们的网页文件(HTML/JS/CSS/icon)都经过一次慢启动，对性能是不小的损耗。另外慢启动是TCP为了减少网络拥塞的一种策略，我们是没有办法改变的。
- **多条TCP连接竞争带宽：** 如果同时建立多条TCP连接，当带宽不足时就会竞争带宽，影响关键资源的下载。
- **HTTP/1.1队头阻塞：** 尽管HTTP/1.1长链接可以通过一个TCP连接传输多个请求，但同一时刻只能处理一个请求，当前请求未结束前，其他请求只能处于阻塞状态。

为了解决以上几个问题，**HTTP/2一个域名只使用一个TCP⻓连接来传输数据，而且请求直接是并行的、非阻塞的，这就是多路复用**

**实现原理：** HTTP/2引入了一个二进制分帧层，客户端和服务端进行传输时，数据会先经过二进制分帧层处理，转化为一个个带有请求ID的帧，这些帧在传输完成后根据ID组合成对应的数据。



## 9. 说说HTTP/3.0

尽管HTTP/2解决了很多1.1的问题，但HTTP/2仍然存在一些缺陷，这些缺陷并不是来自于HTTP/2协议本身，而是来源于底层的TCP协议，我们知道TCP链接是可靠的连接，如果出现了丢包，那么整个连接都要等待重传，HTTP/1.1可以同时使用6个TCP连接，一个阻塞另外五个还能工作，但HTTP/2只有一个TCP连接，阻塞的问题便被放大了。

由于TCP协议已经被广泛使用，我们很难直接修改TCP协议，基于此，HTTP/3选择了一个折衷的方法——UDP协议，HTTP/2在UDP的基础上实现多路复用、0-RTT、TLS加密、流量控制、丢包重传等功能。



> 参考资料：[http发展史(http0.9、http1.0、http1.1、http2、http3)梳理笔记](https://juejin.im/post/6844904001528397837#heading-9) (推荐阅读)



## 10. HTTP和HTTPS有何区别

- HTTPS使用443端口，而HTTP使用80
- HTTPS需要申请证书
- HTTP是超文本传输协议，是明文传输；HTTPS是经过SSL加密的协议，传输更安全
- HTTPS比HTTP慢，因为HTTPS除了TCP握手的三个包，还要加上SSL握手的九个包

## 11. HTTPS是如何进行加密的

我们通过分析几种加密方式，层层递进，理解HTTPS的加密方式以及为什么使用这种加密方式：

> 对称加密

客户端和服务器公用一个密匙用来对消息加解密，这种方式称为对称加密。客户端和服务器约定好一个加密的密匙。客户端在发消息前用该密匙对消息加密，发送给服务器后，服务器再用该密匙进行解密拿到消息。

![img](https://user-gold-cdn.xitu.io/2020/2/3/170097ce30734773?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

这种方式一定程度上保证了数据的安全性，但密钥一旦泄露(密钥在传输过程中被截获)，传输内容就会暴露，因此我们要寻找一种安全传递密钥的方法。



> 非对称加密

采用非对称加密时，客户端和服务端均拥有一个公钥和私钥，公钥加密的内容只有对应的私钥能解密。私钥自己留着，公钥发给对方。这样在发送消息前，先用对方的公钥对消息进行加密，收到后再用自己的私钥进行解密。这样攻击者只拿到传输过程中的公钥也无法破解传输的内容

![img](https://user-gold-cdn.xitu.io/2020/2/3/1700980f4879f2b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

尽管非对称加密解决了由于密钥被获取而导致传输内容泄露的问题，但中间人仍然可以用`篡改公钥`的方式来获取或篡改传输内容，而且非对称加密的性能比对称加密的性能差了不少

![img](https://user-gold-cdn.xitu.io/2020/2/3/17009369c26da64b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



> 第三方认证

上面这种方法的弱点在于，客户端不知道公钥是由服务端返回，还是中间人返回的，因此我们再引入一个第三方认证的环节：即第三方使用私钥加密我们`自己的公钥`，浏览器已经内置一些权威第三方认证机构的公钥，浏览器会使用`第三方的公钥`来解开`第三方私钥加密过的我们自己的公钥`，从而获取公钥，如果能成功解密，就说明获取到的`自己的公钥`是正确的

但第三方认证也未能完全解决问题，第三方认证是面向所有人的，中间人也能申请证书，如果中间人使用自己的证书掉包原证书，客户端还是无法确认公钥的真伪



![img](https://user-gold-cdn.xitu.io/2020/2/3/1700962e1949c343?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



> 数字签名

为了让客户端能够验证公钥的来源，我们给公钥加上一个数字签名，这个数字签名是由企业、网站等各种信息和公钥经过单向hash而来，一旦构成数字签名的信息发生变化，hash值就会改变，这就构成了公钥来源的唯一标识。

具体来说，服务端本地生成一对密钥，然后拿着公钥以及企业、网站等各种信息到CA(第三方认证中心)去申请数字证书，CA会通过一种单向hash算法(比如MD5)，生成一串摘要，这串摘要就是这堆信息的唯一标识，然后CA还会使用自己的私钥对摘要进行加密，连同我们自己服务器的公钥一同发送给我我们。

浏览器拿到数字签名后，会使用**浏览器本地内置**的CA公钥解开数字证书并验证，从而拿到正确的公钥。由于非对称加密性能低下，拿到公钥以后，客户端会随机生成一个对称密钥，使用这个公钥加密并发送给服务端，服务端用自己的私钥解开对称密钥，此后的加密连接就通过这个对称密钥进行对称加密。

综上所述，HTTPS在验证阶段使用非对称加密+第三方认证+数字签名获取正确的公钥，获取到正确的公钥后以对称加密的方式通信



![img](https://user-gold-cdn.xitu.io/2020/4/6/1714e043d3a1add2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



> 参考资料：[看图学HTTPS](https://juejin.im/post/6844903608421449742#heading-5)



# 前端安全

## 什么是CSRF攻击

> CSRF即Cross-site request forgery(跨站请求伪造)，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。

假如黑客在自己的站点上放置了其他网站的外链，例如`"www.weibo.com/api`，默认情况下，浏览器会带着`weibo.com`的cookie访问这个网址，如果用户已登录过该网站且网站没有对CSRF攻击进行防御，那么服务器就会认为是用户本人在调用此接口并执行相关操作，致使账号被劫持。

## 如何防御CSRF攻击

- 验证`Token`：浏览器请求服务器时，服务器返回一个token，每个请求都需要同时带上token和cookie才会被认为是合法请求
- 验证`Referer`：通过验证请求头的Referer来验证来源站点，但请求头很容易伪造
- 设置`SameSite`：设置cookie的SameSite，可以让cookie不随跨域请求发出，但浏览器兼容不一

## 什么是XSS攻击

> XSS即Cross Site Scripting（跨站脚本），指的是通过利用网页开发时留下的漏洞，注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。常见的例如在评论区植入JS代码，用户进入评论页时代码被执行，造成页面被植入广告、账号信息被窃取

## XSS攻击有哪些类型

- **存储型**：即攻击被存储在服务端，常见的是在评论区插入攻击脚本，如果脚本被储存到服务端，那么所有看见对应评论的用户都会受到攻击。
- **反射型**：攻击者将脚本混在URL里，服务端接收到URL将恶意代码当做参数取出并拼接在HTML里返回，浏览器解析此HTML后即执行恶意代码
- **DOM型**：将攻击脚本写在URL中，诱导用户点击该URL，如果URL被解析，那么攻击脚本就会被运行。和前两者的差别主要在于DOM型攻击不经过服务端

## 如何防御XSS攻击

- **输入检查**：对输入内容中的`<script><iframe>`等标签进行转义或者过滤
- **设置httpOnly**：很多XSS攻击目标都是窃取用户cookie伪造身份认证，设置此属性可防止JS获取cookie
- **开启CSP**，即开启白名单，可阻止白名单以外的资源加载和运行



![img](https://user-gold-cdn.xitu.io/2020/4/6/1714ff9939df9d71?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)





# 排序算法

## 1. 手写冒泡排序

> 冒泡排序应该是很多人第一个接触的排序，比较简单，不展开讲解了

```
function bubbleSort(arr){
  for(let i = 0; i < arr.length; i++) {
    for(let j = 0; j < arr.length - i - 1; j++) {
      if(arr[j] > arr[j+1]) {
        let temp = arr[j]
        arr[j] = arr[j+1]
        arr[j+1] = temp
      }
    }
  }
  return arr
}
复制代码
```



## 2. 如何优化一个冒泡排序

> 冒泡排序总会执行(N-1)+(N-2)+(N-3)+..+2+1趟，但如果运行到当中某一趟时排序已经完成，或者输入的是一个有序数组，那么后边的比较就都是多余的，为了避免这种情况，我们增加一个flag，判断排序是否在中途就已经完成（也就是判断有无发生元素交换）

```
function bubbleSort(arr){
  for(let i = 0; i < arr.length; i++) {
  let flag = true
    for(let j = 0; j < arr.length - i - 1; j++) {
      if(arr[j] > arr[j+1]) {
        flag = false
        let temp = arr[j]
        arr[j] = arr[j+1]
        arr[j+1] = temp
      }
    }
    // 这个flag的含义是：如果`某次循环`中没有交换过元素，那么意味着排序已经完成
    if(flag)break;
  }
  return arr
}
复制代码
```



## 3. 手写快速排序

> 快排基本步骤：

1. 选取基准元素
2. 比基准元素小的元素放到左边，大的放右边
3. 在左右子数组中重复步骤一二，直到数组只剩下一个元素
4. 向上逐级合并数组

```
function quickSort(arr) {
    if(arr.length <= 1) return arr          //递归终止条件
    const pivot = arr.length / 2 | 0        //基准点
    const pivotValue = arr.splice(pivot, 1)[0]
    const leftArr = []
    const rightArr = []
    arr.forEach(val => {
        val > pivotValue ? rightArr.push(val) : leftArr.push(val)
    })
    return [ ...quickSort(leftArr), pivotValue, ...quickSort(rightArr)]
}
复制代码
```



## 4. 如何优化一个快速排序

> 原地排序

上边这个快排只是让读者找找感觉，我们不能这样写快排，如果每次都开两个数组，会消耗很多内存空间，数据量大时可能造成内存溢出，我们要避免开新的内存空间，即原地完成排序

我们可以用元素交换来取代开新数组，在每一次分区的时候直接在原数组上交换元素，**将小于基准数的元素挪到数组开头**，以`[5,1,4,2,3]`为例：



![img](https://user-gold-cdn.xitu.io/2020/4/5/17148debd6e97be5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

我们定义一个pos指针, 标识等待置换的元素的位置, 然后逐一遍历数组元素, 遇到比基准数小的就和arr[pos]交换位置, 然后pos++



代码实现：

```
function quickSort(arr, left, right) {          //这个left和right代表分区后“新数组”的区间下标，因为这里没有新开数组，所以需要left/right来确认新数组的位置
    if (left < right) {
        let pos = left - 1                      //pos即“被置换的位置”，第一趟为-1
        for(let i = left; i <= right; i++) {    //循环遍历数组，置换元素
            let pivot = arr[right]              //选取数组最后一位作为基准数，
            if(arr[i] <= pivot) {               //若小于等于基准数，pos++，并置换元素, 这里使用小于等于而不是小于, 其实是为了避免因为重复数据而进入死循环
                pos++
                let temp = arr[pos]
                arr[pos] = arr[i]
                arr[i] = temp
            }
        }
        //一趟排序完成后，pos位置即基准数的位置，以pos的位置分割数组
        quickSort(arr, left, pos - 1)        
        quickSort(arr, pos + 1, right)
    }
    return arr      //数组只包含1或0个元素时(即left>=right)，递归终止
}

//使用
var arr = [5,1,4,2,3]
var start = 0;
var end = arr.length - 1;
quickSort(arr, start, end)
复制代码
```

这个交换的过程还是需要一些时间理解消化的，详细分析可以看这篇：[js算法-快速排序(Quicksort)](https://segmentfault.com/a/1190000017814119)

> 三路快排

上边这个快排还谈不上优化，应当说是快排的纠正写法，其实有两个问题我们还能优化一下：

1. **有序数组的情况**：如果输入的数组是有序的，而取基准点时也顺序取，就可能导致基准点一侧的子数组一直为空, 使时间复杂度退化到O(n2)
2. **大量重复数据的情况**：例如输入的数据是`[1,2,2,2,2,3]`, 无论基准点取1、2还是3, 都会导致基准点两侧数组大小不平衡, 影响快排效率

对于第一个问题, 我们可以通过在取基准点的时候随机化来解决，对于第二个问题，我们可以使用`三路快排`的方式来优化，比方说对于上面的`[1,2,2,2,2,3]`，我们基准点取2，在分区的时候，将数组元素分为`小于2|等于2|大于2`三个区域，其中等于基准点的部分不再进入下一次排序, 这样就大大提高了快排效率



![img](https://user-gold-cdn.xitu.io/2020/4/5/17148dfeda004833?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



## 5. 手写归并排序

> 归并排序和快排的思路类似，都是递归分治，区别在于快排边分区边排序，而归并在分区完成后才会排序



![img](https://user-gold-cdn.xitu.io/2020/2/2/1700388b88d9102c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



```
function mergeSort(arr) {
    if(arr.length <= 1) return arr		//数组元素被划分到剩1个时，递归终止
    const midIndex = arr.length/2 | 0
    const leftArr = arr.slice(0, midIndex)
    const rightArr = arr.slice(midIndex, arr.length)
    return merge(mergeSort(leftArr), mergeSort(rightArr))	//先划分，后合并
}

//合并
function merge(leftArr, rightArr) {
    const result = []
    while(leftArr.length && rightArr.length) {
    	leftArr[0] <= rightArr[0] ? result.push(leftArr.shift()) : result.push(rightArr.shift())
    }
    while(leftArr.length) result.push(leftArr.shift())
    while(rightArr.length) result.push(rightArr.shift())
    return result
}
复制代码
```

## 6. 手写堆排序

> 堆是一棵特殊的树, 只要满足`这棵树是完全二叉树`和`堆中每一个节点的值都大于或小于其左右孩子节点`这两个条件, 那么就是一个堆, 根据`堆中每一个节点的值都大于或小于其左右孩子节点`, 又分为大根堆和小根堆

堆排序的流程：

1. 初始化大(小)根堆，此时根节点为最大(小)值，将根节点与最后一个节点(数组最后一个元素)交换
2. 除开最后一个节点，重新调整大(小)根堆，使根节点为最大(小)值
3. 重复步骤二，直到堆中元素剩一个，排序完成

以`[1,5,4,2,3]`为例构筑大根堆：



![img](https://user-gold-cdn.xitu.io/2020/4/5/17148e2325d08c76?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

代码实现：



```
// 堆排序
const heapSort = array => {
        // 我们用数组来储存这个大根堆,数组就是堆本身
	// 初始化大顶堆，从第一个非叶子结点开始
	for (let i = Math.floor(array.length / 2 - 1); i >= 0; i--) {
		heapify(array, i, array.length);
	}
	// 排序，每一次 for 循环找出一个当前最大值，数组长度减一
	for (let i = Math.floor(array.length - 1); i > 0; i--) {
		// 根节点与最后一个节点交换
		swap(array, 0, i);
		// 从根节点开始调整，并且最后一个结点已经为当前最大值，不需要再参与比较，所以第三个参数为 i，即比较到最后一个结点前一个即可
		heapify(array, 0, i);
	}
	return array;
};

// 交换两个节点
const swap = (array, i, j) => {
	let temp = array[i];
	array[i] = array[j];
	array[j] = temp;
};

// 将 i 结点以下的堆整理为大顶堆，注意这一步实现的基础实际上是：
// 假设结点 i 以下的子堆已经是一个大顶堆，heapify 函数实现的
// 功能是实际上是：找到 结点 i 在包括结点 i 的堆中的正确位置。
// 后面将写一个 for 循环，从第一个非叶子结点开始，对每一个非叶子结点
// 都执行 heapify 操作，所以就满足了结点 i 以下的子堆已经是一大顶堆
const heapify = (array, i, length) => {
	let temp = array[i]; // 当前父节点
	// j < length 的目的是对结点 i 以下的结点全部做顺序调整
	for (let j = 2 * i + 1; j < length; j = 2 * j + 1) {
		temp = array[i]; // 将 array[i] 取出，整个过程相当于找到 array[i] 应处于的位置
		if (j + 1 < length && array[j] < array[j + 1]) {
			j++; // 找到两个孩子中较大的一个，再与父节点比较
		}
		if (temp < array[j]) {
			swap(array, i, j); // 如果父节点小于子节点:交换；否则跳出
			i = j; // 交换后，temp 的下标变为 j
		} else {
			break;
		}
	}
}
复制代码
```

> 参考资料: [JS实现堆排序](https://www.jianshu.com/p/90bf2dcd6a7b)

## 7. 归并、快排、堆排有何区别

| 排序     | 时间复杂度(最好情况) | 时间复杂度(最坏情况) | 空间复杂度   | 稳定性 |
| -------- | -------------------- | -------------------- | ------------ | ------ |
| 快速排序 | O(nlogn)             | O(n^2)               | O(logn)~O(n) | 不稳定 |
| 归并排序 | O(nlogn)             | O(nlogn)             | O(n)         | 稳定   |
| 堆排序   | O(nlogn)             | O(nlogn)             | O(1)         | 不稳定 |

其实从表格中我们可以看到，就时间复杂度而言，快排并没有很大优势，然而为什么快排会成为最常用的排序手段，这是因为时间复杂度只能说明`随着数据量的增加，算法时间代价增长的趋势`，并不直接代表实际执行时间，实际运行时间还包括了很多常数参数的差别，此外在面对不同类型数据(比如有序数据、大量重复数据)时，表现也不同，综合来说，快排的时间效率是最高的

在实际运用中, 并不只使用一种排序手段, 例如V8的`Array.sort()`就采取了**当 n<=10 时, 采用插入排序, 当 n>10 时，采用三路快排**的排序策略



![img](https://user-gold-cdn.xitu.io/2020/4/6/1714ffee2595a85c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)





# 设计模式

设计模式有许多种，这里挑出几个常用的：

| 设计模式   | 描述                                       | 例子                            |
| ---------- | ------------------------------------------ | ------------------------------- |
| 单例模式   | 一个类只能构造出唯一实例                   | Redux/Vuex的store               |
| 工厂模式   | 对创建对象逻辑的封装                       | jQuery的$(selector)             |
| 观察者模式 | 当一个对象被修改时，会自动通知它的依赖对象 | Redux的subscribe、Vue的双向绑定 |
| 装饰器模式 | 对类的包装，动态地拓展类的功能             | React高阶组件、ES7 装饰器       |
| 适配器模式 | 兼容新旧接口，对类的包装                   | 封装旧API                       |
| 代理模式   | 控制对象的访问                             | 事件代理、ES6的Proxy            |

## 1. 介绍一下单一职责原则和开放封闭原则

- **单一职责原则**：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。
- **开放封闭原则**：核心的思想是软件实体（类、模块、函数等）是可扩展的、但不可修改的。也就是说,对扩展是开放的,而对修改是封闭的。



## 2. 单例模式

单例模式即一个类只能构造出唯一实例，单例模式的意义在于**共享、唯一**，`Redux/Vuex`中的store、`JQ`的$或者业务场景中的购物车、登录框都是单例模式的应用

```
class SingletonLogin {
  constructor(name,password){
    this.name = name
    this.password = password
  }
  static getInstance(name,password){
    //判断对象是否已经被创建,若创建则返回旧对象
    if(!this.instance)this.instance = new SingletonLogin(name,password)
    return this.instance
  }
}
 
let obj1 = SingletonLogin.getInstance('CXK','123')
let obj2 = SingletonLogin.getInstance('CXK','321')
 
console.log(obj1===obj2)    // true
console.log(obj1)           // {name:CXK,password:123}
console.log(obj2)           // 输出的依然是{name:CXK,password:123}
复制代码
```



## 3. 工厂模式

工厂模式即对创建对象逻辑的封装，或者可以简单理解为对`new`的封装，这种封装就像创建对象的工厂，故名工厂模式。工厂模式常见于大型项目，比如JQ的$对象，我们创建选择器对象时之所以没有new selector就是因为$()已经是一个工厂方法，其他例子例如`React.createElement()`、`Vue.component()`都是工厂模式的实现。工厂模式有多种：`简单工厂模式`、`工厂方法模式`、`抽象工厂模式`，这里只以简单工厂模式为例：

```
class User {
  constructor(name, auth) {
    this.name = name
    this.auth = auth
  }
}

class UserFactory {
  static createUser(name, auth) {
    //工厂内部封装了创建对象的逻辑:
    //权限为admin时,auth=1, 权限为user时, auth为2
    //使用者在外部创建对象时,不需要知道各个权限对应哪个字段, 不需要知道赋权的逻辑，只需要知道创建了一个管理员和用户
    if(auth === 'admin')  new User(name, 1)
    if(auth === 'user')  new User(name, 2)
  }
}

const admin = UserFactory.createUser('cxk', 'admin');
const user = UserFactory.createUser('cxk', 'user');
复制代码
```



## 4. 观察者模式

观察者模式算是前端最常用的设计模式了，观察者模式概念很简单：观察者监听被观察者的变化，被观察者发生改变时，通知所有的观察者。观察者模式被广泛用于监听事件的实现，有关观察者模式的详细应用，可以看我另一篇讲解[Redux实现的文章](https://juejin.im/post/6844904036013965325#heading-3)

```
//观察者
class Observer {    
  constructor (fn) {      
    this.update = fn    
  }
}
//被观察者
class Subject {    
    constructor() {        
        this.observers = []          //观察者队列    
    }    
    addObserver(observer) {          
        this.observers.push(observer)//往观察者队列添加观察者    
    }    
    notify() {                       //通知所有观察者,实际上是把观察者的update()都执行了一遍       
        this.observers.forEach(observer => {        
            observer.update()            //依次取出观察者,并执行观察者的update方法        
        })    
    }
}

var subject = new Subject()       //被观察者
const update = () => {console.log('被观察者发出通知')}  //收到广播时要执行的方法
var ob1 = new Observer(update)    //观察者1
var ob2 = new Observer(update)    //观察者2
subject.addObserver(ob1)          //观察者1订阅subject的通知
subject.addObserver(ob2)          //观察者2订阅subject的通知
subject.notify()                  //发出广播,执行所有观察者的update方法
复制代码
```

有些文章也把观察者模式称为发布订阅模式，其实二者是有所区别的，发布订阅相较于观察者模式多一个调度中心。



## 5. 装饰器模式

装饰器模式，可以理解为对类的一个包装，动态地拓展类的功能，ES7的`装饰器`语法以及React中的`高阶组件`（HoC）都是这一模式的实现。react-redux的connect()也运用了装饰器模式，这里以ES7的装饰器为例：

```
function info(target) {
  target.prototype.name = '张三'
  target.prototype.age = 10
}

@info
class Man {}

let man = new Man()
man.name // 张三
复制代码
```



## 6. 适配器模式

适配器模式，将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。我们在生活中就常常有使用适配器的场景，例如出境旅游插头插座不匹配，这时我们就需要使用转换插头，也就是适配器来帮我们解决问题。

```
class Adaptee {
  test() {
      return '旧接口'
  }
}
 
class Target {
  constructor() {
      this.adaptee = new Adaptee()
  }
  test() {
      let info = this.adaptee.test()
      return `适配${info}`
  }
}
 
let target = new Target()
console.log(target.test())
复制代码
```



## 7. 代理模式

代理模式，为一个对象找一个替代对象，以便对原对象进行访问。即在访问者与目标对象之间加一层代理，通过代理做授权和控制。最常见的例子是经纪人代理明星业务，假设你作为一个投资者，想联系明星打广告，那么你就需要先经过代理经纪人，经纪人对你的资质进行考察，并通知你明星排期，替明星本人过滤不必要的信息。事件代理、`JQuery的$.proxy`、ES6的`proxy`都是这一模式的实现，下面以ES6的proxy为例：

```
const idol = {
  name: '蔡x抻',
  phone: 10086,
  price: 1000000  //报价
}

const agent = new Proxy(idol, {
  get: function(target) {
    //拦截明星电话的请求,只提供经纪人电话
    return '经纪人电话:10010'
  },
  set: function(target, key, value) {
    if(key === 'price' ) {
      //经纪人过滤资质
      if(value < target.price) throw new Error('报价过低')
      target.price = value
    }
  }
})


agent.phone        //经纪人电话:10010
agent.price = 100  //Uncaught Error: 报价过低
复制代码
```



![img](https://user-gold-cdn.xitu.io/2020/4/5/171465b92f6ded5e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)





# HTML相关

## 1. 说说HTML5在标签、属性、存储、API上的新特性

- 标签：新增语义化标签（`aside / figure / section / header / footer / nav`等），增加多媒体标签`video`和`audio`，使得样式和结构更加分离
- 属性：增强表单，主要是增强了`input`的type属性；`meta`增加charset以设置字符集；`script`增加async以异步加载脚本
- 存储：增加`localStorage`、`sessionStorage`和`indexedDB`，引入了`application cache`对web和应用进行缓存
- API：增加`拖放API`、`地理定位`、`SVG绘图`、`canvas绘图`、`Web Worker`、`WebSocket`



## 2. doctype的作用是什么？

声明文档类型，告知浏览器用什么文档标准解析这个文档：

- 怪异模式：浏览器使用自己的模式解析文档，不加doctype时默认为怪异模式
- 标准模式：浏览器以W3C的标准解析文档



## 3. 几种前端储存以及它们之间的区别

- **cookies**： HTML5之前本地储存的主要方式，大小只有4k，HTTP请求头会自动带上cookie，兼容性好
- **localStorage**：HTML5新特性，持久性存储，即使页面关闭也不会被清除，以键值对的方式存储，大小为5M
- **sessionStorage**：HTML5新特性，操作及大小同localStorage，和localStorage的区别在于sessionStorage在选项卡(页面)被关闭时即清除，且不同选项卡之间的sessionStorage不互通
- **IndexedDB**： NoSQL型数据库，类比MongoDB，使用键值对进行储存，异步操作数据库，支持事务，储存空间可以在250MB以上，但是IndexedDB受同源策略限制
- **Web SQL**：是在浏览器上模拟的关系型数据库，开发者可以通过SQL语句来操作Web SQL，是HTML5以外一套独立的规范，兼容性差



## 4. href和src有什么区别

```
href（hyperReference）`即超文本引用：当浏览器遇到href时，会并行的地下载资源，不会阻塞页面解析，例如我们使用`<link>`引入CSS，浏览器会并行地下载CSS而不阻塞页面解析. 因此我们在引入CSS时建议使用`<link>`而不是`@import
<link href="style.css" rel="stylesheet" />
复制代码
```

`src（resource）`即资源，当浏览器遇到src时，会暂停页面解析，直到该资源下载或执行完毕，这也是script标签之所以放底部的原因

```
<script src="script.js"></script>
复制代码
```



## 5. meta有哪些属性，作用是什么

meta标签用于描述网页的`元信息`，如网站作者、描述、关键词，meta通过`name=xxx`和`content=xxx`的形式来定义信息，常用设置如下：

- charset：定义HTML文档的字符集

```
 <meta charset="UTF-8" >
复制代码
```

- http-equiv：可用于模拟http请求头，可设置过期时间、缓存、刷新

```
＜meta http-equiv="expires" content="Wed, 20 Jun 2019 22:33:00 GMT"＞
复制代码
```

- viewport：视口，用于控制页面宽高及缩放比例

```
<meta 
    name="viewport" 
    content="width=device-width, initial-scale=1, maximum-scale=1"
>
复制代码
```

## 6. viewport有哪些参数，作用是什么

- width/height，宽高，默认宽度980px
- initial-scale，初始缩放比例，1~10
- maximum-scale/minimum-scale，允许用户缩放的最大/小比例
- user-scalable，用户是否可以缩放 (yes/no)

## 7. http-equive属性的作用和参数

- expires，指定过期时间
- progma，设置no-cache可以禁止缓存
- refresh，定时刷新
- set-cookie，可以设置cookie
- X-UA-Compatible，使用浏览器版本
- apple-mobile-web-app-status-bar-style，针对WebApp全屏模式，隐藏状态栏/设置状态栏颜色



![img](https://user-gold-cdn.xitu.io/2020/4/5/171467924210a82d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)





# CSS相关

## 清除浮动的方法

> 为什么要清除浮动：清除浮动是为了解决子元素浮动而导致父元素高度塌陷的问题



![img](https://user-gold-cdn.xitu.io/2020/4/6/1714f4a5ef80d8ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**1.添加新元素**



```
<div class="parent">
  <div class="child"></div>
  <!-- 添加一个空元素，利用css提供的clear:both清除浮动 -->
  <div style="clear: both"></div>
</div>  
复制代码
```

**2.使用伪元素**

```
/* 对父元素添加伪元素 */
.parent::after{
  content: "";
  display: block;
  height: 0;
  clear:both;
}
复制代码
```

**3.触发父元素BFC**

```
/* 触发父元素BFC */
.parent {
  overflow: hidden;
  /* float: left; */
  /* position: absolute; */
  /* display: inline-block */
  /* 以上属性均可触发BFC */
}
复制代码
```



## 介绍一下flex布局

其实我本来还写了一节水平/垂直居中相关的，不过感觉内容过于基础还占长篇幅，所以删去了，作为一篇总结性的文章，这一小节也不应该从“flex是什么”开始讲，主轴、侧轴这些概念相信用过flex布局都知道，所以我们直接flex的几个属性讲起：

> 容器属性（使用在flex布局容器上的属性）

- justify-content
   **定义了子元素在主轴(横轴)上的对齐方式**

```
.container {
    justify-content: center | flex-start | flex-end | space-between | space-around;
    /* 主轴对齐方式：居中 | 左对齐(默认值) | 右对齐 | 两端对齐(子元素间边距相等) | 周围对齐(每个子元素两侧margin相等） */
}
复制代码
```

- align-items
   **定义了定义项目在交叉轴(竖轴)上对齐方式**

```
.container {
    align-items: center | flex-start | flex-end | baseline | stretch;
    /* 侧轴对齐方式：居中 | 上对齐 | 下对齐 | 项目的第一行文字的基线对齐 | 如果子元素未设置高度，将占满整个容器的高度（默认值） */
}
复制代码
```

- flex-direction
   **主轴(横轴)方向**

```
.container {
    flex-direction: row | row-reverse | column | column-reverse;
    /* 主轴方向：水平由左至右排列（默认值） | 水平由右向左 | 垂直由上至下 | 垂直由下至上 */
}
复制代码
```

- flex-wrap
   **换行方式**

```
.container {
    flex-wrap: nowrap | wrap | wrap-reverse;
    /* 换行方式：不换行（默认值） | 换行 | 反向换行 */
}
复制代码
```

- flex-flow
   **flex-flow属性是flex-direction属性和flex-wrap的简写**

```
.container {
    flex-flow: <flex-direction> || <flex-wrap>;
    /* 默认值：row nowrap */
}
复制代码
```

- align-content
   **定义多根轴线的对齐方式**

```
.container {
    align-content: center | flex-start | flex-end | space-between | space-around | stretch;
    /* 默认值：与交叉轴的中点对齐 | 与交叉轴的起点对齐 | 与交叉轴的终点对齐 | 与交叉轴两端对齐 | 每根轴线两侧的间隔都相等 | （默认值）：轴线占满整个交叉轴 */
}
复制代码
```



> 项目属性（使用在容器内子元素上的属性）

- flex-grow
   **定义项目的放大比例，默认为0，即使有剩余空间也不放大**。如果所有子元素flex-grow为1，那么将等分剩余空间，如果某个子元素flex-grow为2，那么这个子元素将占据2倍的剩余空间

```
.item {
  flex-grow: <number>; /* default 0 */
}
复制代码
```

- flex-shrink
   **定义项目的缩小比例，默认为1，即如果空间不足，子元素将缩小**。如果所有子元素`flex-shrink`都为1，某个子元素`flex-shrink`为0，那么该子元素将不缩小

```
.item {
  flex-shrink: <number>; /* default 1 */
}
复制代码
```

- flex-basis
   **定义在分配多余空间之前，项目占据的主轴空间**，默认auto，即子元素本来的大小，如果设定为一个固定的值，那么子元素将占据固定空间

```
.item {
  flex-basis: <length> | auto; /* default auto */
}
复制代码
```

- flex
   **flex属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为0 1 auto，即有剩余空间不放大，剩余空间不够将缩小，子元素占据自身大小**

```
.item {
  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
}
复制代码
```

flex有两个快捷值：`auto`和`none`，分别代表`1 1 auto`（有剩余空间则平均分配，空间不够将等比缩小，子元素占据空间等于自身大小）和`0 0 auto`（有剩余空间也不分配，空间不够也不缩小，子元素占据空间等于自身大小）

- order
   **定义项目的排列顺序。数值越小，排列越靠前，默认为0**

```
.item {
  order: <integer>;
}
复制代码
```

- align-self
   **定义单个子元素的排列方式**，例如align-items设置了center，使得所有子元素居中对齐，那么可以通过给某个子元素设置align-self来单独设置子元素的排序方式

```
.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
复制代码
```

> 参考资料：[阮一峰Flex布局](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)



## 常见布局

> 编辑中，请稍等-_-||



## 什么是BFC

BFC全称 Block Formatting Context 即`块级格式上下文`，简单的说，BFC是页面上的一个隔离的独立容器，不受外界干扰或干扰外界

## 如何触发BFC

- `float`不为 none
- `overflow`的值不为 visible
- `position` 为 absolute 或 fixed
- `display`的值为 inline-block 或 table-cell 或 table-caption 或 grid

## BFC的渲染规则是什么

- BFC是页面上的一个隔离的独立容器，不受外界干扰或干扰外界
- 计算BFC的高度时，浮动子元素也参与计算（即内部有浮动元素时也不会发生高度塌陷）
- BFC的区域不会与float的元素区域重叠
- BFC内部的元素会在垂直方向上放置
- BFC内部两个相邻元素的margin会发生重叠

## BFC的应用场景

- **清除浮动**：BFC内部的浮动元素会参与高度计算，因此可用于清除浮动，防止高度塌陷
- **避免某元素被浮动元素覆盖**：BFC的区域不会与浮动元素的区域重叠
- **阻止外边距重叠**：属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠



![img](https://user-gold-cdn.xitu.io/2020/4/6/1714e0acba58457f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


